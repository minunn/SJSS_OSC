"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * VRChat API Documentation
 *
 * The version of the OpenAPI document: 1.16.5
 * Contact: vrchatapi.lpv0t@aries.fyi
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FriendsApiFp = exports.FriendsApiAxiosParamCreator = exports.FilesApi = exports.FilesApiFactory = exports.FilesApiFp = exports.FilesApiAxiosParamCreator = exports.FavoritesApi = exports.FavoritesApiFactory = exports.FavoritesApiFp = exports.FavoritesApiAxiosParamCreator = exports.EconomyApi = exports.EconomyApiFactory = exports.EconomyApiFp = exports.EconomyApiAxiosParamCreator = exports.AvatarsApi = exports.AvatarsApiFactory = exports.AvatarsApiFp = exports.AvatarsApiAxiosParamCreator = exports.AuthenticationApi = exports.AuthenticationApiFactory = exports.AuthenticationApiFp = exports.AuthenticationApiAxiosParamCreator = exports.UserStatus = exports.UserState = exports.TransactionStatus = exports.SubscriptionPeriod = exports.SortOption = exports.ReleaseStatus = exports.Region = exports.PlayerModerationType = exports.OrderOption = exports.NotificationType = exports.MIMEType = exports.LicenseType = exports.LicenseAction = exports.InviteMessageType = exports.InstanceType = exports.InfoPushDataClickableCommandEnum = exports.GroupUserVisibility = exports.GroupSearchSort = exports.GroupRoleTemplate = exports.GroupPrivacy = exports.GroupMemberStatus = exports.GroupJoinState = exports.FileStatus = exports.FileDataCategoryEnum = exports.FavoriteType = exports.FavoriteGroupVisibility = exports.DeveloperType = exports.DeploymentGroup = void 0;
exports.WorldsApi = exports.WorldsApiFactory = exports.WorldsApiFp = exports.WorldsApiAxiosParamCreator = exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.SystemApi = exports.SystemApiFactory = exports.SystemApiFp = exports.SystemApiAxiosParamCreator = exports.PlayermoderationApi = exports.PlayermoderationApiFactory = exports.PlayermoderationApiFp = exports.PlayermoderationApiAxiosParamCreator = exports.PermissionsApi = exports.PermissionsApiFactory = exports.PermissionsApiFp = exports.PermissionsApiAxiosParamCreator = exports.NotificationsApi = exports.NotificationsApiFactory = exports.NotificationsApiFp = exports.NotificationsApiAxiosParamCreator = exports.InviteApi = exports.InviteApiFactory = exports.InviteApiFp = exports.InviteApiAxiosParamCreator = exports.InstancesApi = exports.InstancesApiFactory = exports.InstancesApiFp = exports.InstancesApiAxiosParamCreator = exports.GroupsApi = exports.GroupsApiFactory = exports.GroupsApiFp = exports.GroupsApiAxiosParamCreator = exports.FriendsApi = exports.FriendsApiFactory = void 0;
var axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("./common");
// @ts-ignore
var base_1 = require("./base");
var axios_cookiejar_support_1 = require("axios-cookiejar-support");
(0, axios_cookiejar_support_1.default)(axios_1.default);
var tough_cookie_1 = require("tough-cookie");
axios_1.default.defaults.jar = new tough_cookie_1.CookieJar();
axios_1.default.defaults.withCredentials = true;
/**
 * Used to identify which API deployment cluster is currently responding.  `blue` and `green` are used by Production. `grape`and `cherry` are used during Development.  [Blue Green Deployment by Martin Fowler](https://martinfowler.com/bliki/BlueGreenDeployment.html)
 * @export
 * @enum {string}
 */
exports.DeploymentGroup = {
    Blue: 'blue',
    Green: 'green',
    Grape: 'grape',
    Cherry: 'cherry'
};
/**
 * \"none\" User is a normal user \"trusted\" Unknown \"internal\" Is a VRChat Developer \"moderator\" Is a VRChat Moderator  Staff can hide their developerType at will.
 * @export
 * @enum {string}
 */
exports.DeveloperType = {
    None: 'none',
    Trusted: 'trusted',
    Internal: 'internal',
    Moderator: 'moderator'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.FavoriteGroupVisibility = {
    Private: 'private',
    Friends: 'friends',
    Public: 'public'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.FavoriteType = {
    World: 'world',
    Friend: 'friend',
    Avatar: 'avatar'
};
exports.FileDataCategoryEnum = {
    Multipart: 'multipart',
    Queued: 'queued',
    Simple: 'simple'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.FileStatus = {
    Waiting: 'waiting',
    Complete: 'complete',
    None: 'none',
    Queued: 'queued'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.GroupJoinState = {
    Closed: 'closed',
    Invite: 'invite',
    Request: 'request',
    Open: 'open'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.GroupMemberStatus = {
    Inactive: 'inactive',
    Member: 'member',
    Requested: 'requested',
    Invited: 'invited'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.GroupPrivacy = {
    Default: 'default',
    Private: 'private'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.GroupRoleTemplate = {
    Default: 'default',
    ManagedFree: 'managedFree',
    ManagedInvite: 'managedInvite',
    ManagedRequest: 'managedRequest'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.GroupSearchSort = {
    Asc: 'joinedAt:asc',
    Desc: 'joinedAt:desc'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.GroupUserVisibility = {
    Visible: 'visible',
    Hidden: 'hidden',
    Friends: 'friends'
};
exports.InfoPushDataClickableCommandEnum = {
    OpenUrl: 'OpenURL',
    OpenVrcPlusMenu: 'OpenVRCPlusMenu',
    OpenSafetyMenu: 'OpenSafetyMenu',
    CannedWorldSearch: 'CannedWorldSearch'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.InstanceType = {
    Public: 'public',
    Hidden: 'hidden',
    Friends: 'friends',
    Private: 'private',
    Group: 'group'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.InviteMessageType = {
    Message: 'message',
    Response: 'response',
    Request: 'request',
    RequestResponse: 'requestResponse'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.LicenseAction = {
    Wear: 'wear',
    Have: 'have'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.LicenseType = {
    Avatar: 'avatar',
    LicenseGroup: 'licenseGroup',
    Permission: 'permission',
    Product: 'product'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.MIMEType = {
    ImageJpeg: 'image/jpeg',
    ImageJpg: 'image/jpg',
    ImagePng: 'image/png',
    ImageWebp: 'image/webp',
    ImageGif: 'image/gif',
    ImageBmp: 'image/bmp',
    ImageSvgxml: 'image/svg＋xml',
    ImageTiff: 'image/tiff',
    ApplicationXAvatar: 'application/x-avatar',
    ApplicationXWorld: 'application/x-world',
    ApplicationGzip: 'application/gzip',
    ApplicationXRsyncSignature: 'application/x-rsync-signature',
    ApplicationXRsyncDelta: 'application/x-rsync-delta',
    ApplicationOctetStream: 'application/octet-stream'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.NotificationType = {
    FriendRequest: 'friendRequest',
    Invite: 'invite',
    InviteResponse: 'inviteResponse',
    Message: 'message',
    RequestInvite: 'requestInvite',
    RequestInviteResponse: 'requestInviteResponse',
    Votetokick: 'votetokick'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.OrderOption = {
    Ascending: 'ascending',
    Descending: 'descending'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.PlayerModerationType = {
    Mute: 'mute',
    Unmute: 'unmute',
    Block: 'block',
    Unblock: 'unblock',
    InteractOn: 'interactOn',
    InteractOff: 'interactOff'
};
/**
 * API/Photon region.
 * @export
 * @enum {string}
 */
exports.Region = {
    Us: 'us',
    Use: 'use',
    Usw: 'usw',
    Eu: 'eu',
    Jp: 'jp',
    Unknown: 'unknown'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ReleaseStatus = {
    Public: 'public',
    Private: 'private',
    Hidden: 'hidden',
    All: 'all'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SortOption = {
    Popularity: 'popularity',
    Heat: 'heat',
    Trust: 'trust',
    Shuffle: 'shuffle',
    Random: 'random',
    Favorites: 'favorites',
    ReportScore: 'reportScore',
    ReportCount: 'reportCount',
    PublicationDate: 'publicationDate',
    LabsPublicationDate: 'labsPublicationDate',
    Created: 'created',
    CreatedAt: '_created_at',
    Updated: 'updated',
    UpdatedAt: '_updated_at',
    Order: 'order',
    Relevance: 'relevance',
    Magic: 'magic',
    Name: 'name'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SubscriptionPeriod = {
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.TransactionStatus = {
    Active: 'active',
    Failed: 'failed',
    Expired: 'expired',
    Chargeback: 'chargeback'
};
/**
 * * \"online\" User is online in VRChat * \"active\" User is online, but not in VRChat * \"offline\" User is offline  Always offline when returned through `getCurrentUser` (/auth/user).
 * @export
 * @enum {string}
 */
exports.UserState = {
    Offline: 'offline',
    Active: 'active',
    Online: 'online'
};
/**
 * Defines the User\'s current status, for example \"ask me\", \"join me\" or \"offline. This status is a combined indicator of their online activity and privacy preference.
 * @export
 * @enum {string}
 */
exports.UserStatus = {
    Active: 'active',
    JoinMe: 'join me',
    AskMe: 'ask me',
    Busy: 'busy',
    Offline: 'offline'
};
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
var AuthenticationApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
         * @summary Check User Exists
         * @param {string} [email] Filter by email.
         * @param {string} [displayName] Filter by displayName.
         * @param {string} [userId] Filter by UserID.
         * @param {string} [excludeUserId] Exclude by UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserExists: function (email, displayName, userId, excludeUserId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/exists";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (email !== undefined) {
                        localVarQueryParameter['email'] = email;
                    }
                    if (displayName !== undefined) {
                        localVarQueryParameter['displayName'] = displayName;
                    }
                    if (userId !== undefined) {
                        localVarQueryParameter['userId'] = userId;
                    }
                    if (excludeUserId !== undefined) {
                        localVarQueryParameter['excludeUserId'] = excludeUserId;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
         * @summary Delete User
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteUser', 'userId', userId);
                    localVarPath = "/users/{userId}/delete"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
         * @summary Login and/or Get Current User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/user";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    // authentication authHeader required
                    // http basic authentication required
                    (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
                    // authentication twoFactorAuthCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Invalidates the login session.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/logout";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code
         * @param {TwoFactorAuthCode} [twoFactorAuthCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA: function (twoFactorAuthCode, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/twofactorauth/totp/verify";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(twoFactorAuthCode, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Finishes the login sequence with an 2FA email code.
         * @summary Verify 2FA email code
         * @param {TwoFactorEmailCode} [twoFactorEmailCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FAEmailCode: function (twoFactorEmailCode, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/twofactorauth/emailotp/verify";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(twoFactorEmailCode, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Verify whether the currently provided Auth Token is valid.
         * @summary Verify Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuthToken: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code with Recovery code
         * @param {TwoFactorAuthCode} [twoFactorAuthCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRecoveryCode: function (twoFactorAuthCode, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/twofactorauth/otp/verify";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(twoFactorAuthCode, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.AuthenticationApiAxiosParamCreator = AuthenticationApiAxiosParamCreator;
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
var AuthenticationApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AuthenticationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
         * @summary Check User Exists
         * @param {string} [email] Filter by email.
         * @param {string} [displayName] Filter by displayName.
         * @param {string} [userId] Filter by UserID.
         * @param {string} [excludeUserId] Exclude by UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserExists: function (email, displayName, userId, excludeUserId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.checkUserExists(email, displayName, userId, excludeUserId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
         * @summary Delete User
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteUser(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
         * @summary Login and/or Get Current User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCurrentUser(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Invalidates the login session.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.logout(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code
         * @param {TwoFactorAuthCode} [twoFactorAuthCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA: function (twoFactorAuthCode, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.verify2FA(twoFactorAuthCode, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Finishes the login sequence with an 2FA email code.
         * @summary Verify 2FA email code
         * @param {TwoFactorEmailCode} [twoFactorEmailCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FAEmailCode: function (twoFactorEmailCode, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.verify2FAEmailCode(twoFactorEmailCode, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Verify whether the currently provided Auth Token is valid.
         * @summary Verify Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuthToken: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.verifyAuthToken(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code with Recovery code
         * @param {TwoFactorAuthCode} [twoFactorAuthCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRecoveryCode: function (twoFactorAuthCode, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.verifyRecoveryCode(twoFactorAuthCode, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AuthenticationApiFp = AuthenticationApiFp;
/**
 * AuthenticationApi - factory interface
 * @export
 */
var AuthenticationApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AuthenticationApiFp)(configuration);
    return {
        /**
         * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
         * @summary Check User Exists
         * @param {string} [email] Filter by email.
         * @param {string} [displayName] Filter by displayName.
         * @param {string} [userId] Filter by UserID.
         * @param {string} [excludeUserId] Exclude by UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserExists: function (email, displayName, userId, excludeUserId, options) {
            return localVarFp.checkUserExists(email, displayName, userId, excludeUserId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
         * @summary Delete User
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: function (userId, options) {
            return localVarFp.deleteUser(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
         * @summary Login and/or Get Current User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: function (options) {
            return localVarFp.getCurrentUser(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Invalidates the login session.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: function (options) {
            return localVarFp.logout(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code
         * @param {TwoFactorAuthCode} [twoFactorAuthCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA: function (twoFactorAuthCode, options) {
            return localVarFp.verify2FA(twoFactorAuthCode, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Finishes the login sequence with an 2FA email code.
         * @summary Verify 2FA email code
         * @param {TwoFactorEmailCode} [twoFactorEmailCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FAEmailCode: function (twoFactorEmailCode, options) {
            return localVarFp.verify2FAEmailCode(twoFactorEmailCode, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Verify whether the currently provided Auth Token is valid.
         * @summary Verify Auth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuthToken: function (options) {
            return localVarFp.verifyAuthToken(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
         * @summary Verify 2FA code with Recovery code
         * @param {TwoFactorAuthCode} [twoFactorAuthCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRecoveryCode: function (twoFactorAuthCode, options) {
            return localVarFp.verifyRecoveryCode(twoFactorAuthCode, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AuthenticationApiFactory = AuthenticationApiFactory;
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
var AuthenticationApi = /** @class */ (function (_super) {
    __extends(AuthenticationApi, _super);
    function AuthenticationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
     * @summary Check User Exists
     * @param {string} [email] Filter by email.
     * @param {string} [displayName] Filter by displayName.
     * @param {string} [userId] Filter by UserID.
     * @param {string} [excludeUserId] Exclude by UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.checkUserExists = function (email, displayName, userId, excludeUserId, options) {
        var _this = this;
        return (0, exports.AuthenticationApiFp)(this.configuration).checkUserExists(email, displayName, userId, excludeUserId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     * @summary Delete User
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.deleteUser = function (userId, options) {
        var _this = this;
        return (0, exports.AuthenticationApiFp)(this.configuration).deleteUser(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     * @summary Login and/or Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.getCurrentUser = function (options) {
        var _this = this;
        return (0, exports.AuthenticationApiFp)(this.configuration).getCurrentUser(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Invalidates the login session.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.logout = function (options) {
        var _this = this;
        return (0, exports.AuthenticationApiFp)(this.configuration).logout(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code
     * @param {TwoFactorAuthCode} [twoFactorAuthCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.verify2FA = function (twoFactorAuthCode, options) {
        var _this = this;
        return (0, exports.AuthenticationApiFp)(this.configuration).verify2FA(twoFactorAuthCode, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Finishes the login sequence with an 2FA email code.
     * @summary Verify 2FA email code
     * @param {TwoFactorEmailCode} [twoFactorEmailCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.verify2FAEmailCode = function (twoFactorEmailCode, options) {
        var _this = this;
        return (0, exports.AuthenticationApiFp)(this.configuration).verify2FAEmailCode(twoFactorEmailCode, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Verify whether the currently provided Auth Token is valid.
     * @summary Verify Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.verifyAuthToken = function (options) {
        var _this = this;
        return (0, exports.AuthenticationApiFp)(this.configuration).verifyAuthToken(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code with Recovery code
     * @param {TwoFactorAuthCode} [twoFactorAuthCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.verifyRecoveryCode = function (twoFactorAuthCode, options) {
        var _this = this;
        return (0, exports.AuthenticationApiFp)(this.configuration).verifyRecoveryCode(twoFactorAuthCode, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AuthenticationApi;
}(base_1.BaseAPI));
exports.AuthenticationApi = AuthenticationApi;
/**
 * AvatarsApi - axios parameter creator
 * @export
 */
var AvatarsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
         * @summary Create Avatar
         * @param {CreateAvatarRequest} [createAvatarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAvatar: function (createAvatarRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/avatars";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAvatarRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
         * @summary Delete Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAvatar: function (avatarId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'avatarId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteAvatar', 'avatarId', avatarId);
                    localVarPath = "/avatars/{avatarId}"
                        .replace("{".concat("avatarId", "}"), encodeURIComponent(String(avatarId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get information about a specific Avatar.
         * @summary Get Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatar: function (avatarId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'avatarId' is not null or undefined
                    (0, common_1.assertParamExists)('getAvatar', 'avatarId', avatarId);
                    localVarPath = "/avatars/{avatarId}"
                        .replace("{".concat("avatarId", "}"), encodeURIComponent(String(avatarId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Search and list favorited avatars by query filters.
         * @summary List Favorited Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritedAvatars: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/avatars/favorites";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (featured !== undefined) {
                        localVarQueryParameter['featured'] = featured;
                    }
                    if (sort !== undefined) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (search !== undefined) {
                        localVarQueryParameter['search'] = search;
                    }
                    if (tag !== undefined) {
                        localVarQueryParameter['tag'] = tag;
                    }
                    if (notag !== undefined) {
                        localVarQueryParameter['notag'] = notag;
                    }
                    if (releaseStatus !== undefined) {
                        localVarQueryParameter['releaseStatus'] = releaseStatus;
                    }
                    if (maxUnityVersion !== undefined) {
                        localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
                    }
                    if (minUnityVersion !== undefined) {
                        localVarQueryParameter['minUnityVersion'] = minUnityVersion;
                    }
                    if (platform !== undefined) {
                        localVarQueryParameter['platform'] = platform;
                    }
                    if (userId !== undefined) {
                        localVarQueryParameter['userId'] = userId;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get the current avatar for the user. This will return an error for any other user than the one logged in.
         * @summary Get Own Avatar
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnAvatar: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('getOwnAvatar', 'userId', userId);
                    localVarPath = "/users/{userId}/avatar"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
         * @summary Search Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAvatars: function (featured, sort, user, userId, n, order, offset, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/avatars";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (featured !== undefined) {
                        localVarQueryParameter['featured'] = featured;
                    }
                    if (sort !== undefined) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (user !== undefined) {
                        localVarQueryParameter['user'] = user;
                    }
                    if (userId !== undefined) {
                        localVarQueryParameter['userId'] = userId;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (tag !== undefined) {
                        localVarQueryParameter['tag'] = tag;
                    }
                    if (notag !== undefined) {
                        localVarQueryParameter['notag'] = notag;
                    }
                    if (releaseStatus !== undefined) {
                        localVarQueryParameter['releaseStatus'] = releaseStatus;
                    }
                    if (maxUnityVersion !== undefined) {
                        localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
                    }
                    if (minUnityVersion !== undefined) {
                        localVarQueryParameter['minUnityVersion'] = minUnityVersion;
                    }
                    if (platform !== undefined) {
                        localVarQueryParameter['platform'] = platform;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Switches into that avatar.
         * @summary Select Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectAvatar: function (avatarId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'avatarId' is not null or undefined
                    (0, common_1.assertParamExists)('selectAvatar', 'avatarId', avatarId);
                    localVarPath = "/avatars/{avatarId}/select"
                        .replace("{".concat("avatarId", "}"), encodeURIComponent(String(avatarId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Switches into that avatar as your fallback avatar.
         * @summary Select Fallback Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectFallbackAvatar: function (avatarId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'avatarId' is not null or undefined
                    (0, common_1.assertParamExists)('selectFallbackAvatar', 'avatarId', avatarId);
                    localVarPath = "/avatars/{avatarId}/selectFallback"
                        .replace("{".concat("avatarId", "}"), encodeURIComponent(String(avatarId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Update information about a specific avatar.
         * @summary Update Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {UpdateAvatarRequest} [updateAvatarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar: function (avatarId, updateAvatarRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'avatarId' is not null or undefined
                    (0, common_1.assertParamExists)('updateAvatar', 'avatarId', avatarId);
                    localVarPath = "/avatars/{avatarId}"
                        .replace("{".concat("avatarId", "}"), encodeURIComponent(String(avatarId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateAvatarRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.AvatarsApiAxiosParamCreator = AvatarsApiAxiosParamCreator;
/**
 * AvatarsApi - functional programming interface
 * @export
 */
var AvatarsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AvatarsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
         * @summary Create Avatar
         * @param {CreateAvatarRequest} [createAvatarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAvatar: function (createAvatarRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createAvatar(createAvatarRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
         * @summary Delete Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAvatar: function (avatarId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteAvatar(avatarId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get information about a specific Avatar.
         * @summary Get Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatar: function (avatarId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAvatar(avatarId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Search and list favorited avatars by query filters.
         * @summary List Favorited Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritedAvatars: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFavoritedAvatars(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get the current avatar for the user. This will return an error for any other user than the one logged in.
         * @summary Get Own Avatar
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnAvatar: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getOwnAvatar(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
         * @summary Search Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAvatars: function (featured, sort, user, userId, n, order, offset, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.searchAvatars(featured, sort, user, userId, n, order, offset, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Switches into that avatar.
         * @summary Select Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectAvatar: function (avatarId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.selectAvatar(avatarId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Switches into that avatar as your fallback avatar.
         * @summary Select Fallback Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectFallbackAvatar: function (avatarId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.selectFallbackAvatar(avatarId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update information about a specific avatar.
         * @summary Update Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {UpdateAvatarRequest} [updateAvatarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar: function (avatarId, updateAvatarRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateAvatar(avatarId, updateAvatarRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AvatarsApiFp = AvatarsApiFp;
/**
 * AvatarsApi - factory interface
 * @export
 */
var AvatarsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AvatarsApiFp)(configuration);
    return {
        /**
         * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
         * @summary Create Avatar
         * @param {CreateAvatarRequest} [createAvatarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAvatar: function (createAvatarRequest, options) {
            return localVarFp.createAvatar(createAvatarRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
         * @summary Delete Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAvatar: function (avatarId, options) {
            return localVarFp.deleteAvatar(avatarId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get information about a specific Avatar.
         * @summary Get Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvatar: function (avatarId, options) {
            return localVarFp.getAvatar(avatarId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Search and list favorited avatars by query filters.
         * @summary List Favorited Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritedAvatars: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
            return localVarFp.getFavoritedAvatars(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the current avatar for the user. This will return an error for any other user than the one logged in.
         * @summary Get Own Avatar
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnAvatar: function (userId, options) {
            return localVarFp.getOwnAvatar(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
         * @summary Search Avatars
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAvatars: function (featured, sort, user, userId, n, order, offset, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
            return localVarFp.searchAvatars(featured, sort, user, userId, n, order, offset, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Switches into that avatar.
         * @summary Select Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectAvatar: function (avatarId, options) {
            return localVarFp.selectAvatar(avatarId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Switches into that avatar as your fallback avatar.
         * @summary Select Fallback Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectFallbackAvatar: function (avatarId, options) {
            return localVarFp.selectFallbackAvatar(avatarId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update information about a specific avatar.
         * @summary Update Avatar
         * @param {string} avatarId Must be a valid avatar ID.
         * @param {UpdateAvatarRequest} [updateAvatarRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar: function (avatarId, updateAvatarRequest, options) {
            return localVarFp.updateAvatar(avatarId, updateAvatarRequest, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AvatarsApiFactory = AvatarsApiFactory;
/**
 * AvatarsApi - object-oriented interface
 * @export
 * @class AvatarsApi
 * @extends {BaseAPI}
 */
var AvatarsApi = /** @class */ (function (_super) {
    __extends(AvatarsApi, _super);
    function AvatarsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
     * @summary Create Avatar
     * @param {CreateAvatarRequest} [createAvatarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    AvatarsApi.prototype.createAvatar = function (createAvatarRequest, options) {
        var _this = this;
        return (0, exports.AvatarsApiFp)(this.configuration).createAvatar(createAvatarRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
     * @summary Delete Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    AvatarsApi.prototype.deleteAvatar = function (avatarId, options) {
        var _this = this;
        return (0, exports.AvatarsApiFp)(this.configuration).deleteAvatar(avatarId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get information about a specific Avatar.
     * @summary Get Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    AvatarsApi.prototype.getAvatar = function (avatarId, options) {
        var _this = this;
        return (0, exports.AvatarsApiFp)(this.configuration).getAvatar(avatarId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Search and list favorited avatars by query filters.
     * @summary List Favorited Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    AvatarsApi.prototype.getFavoritedAvatars = function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
        var _this = this;
        return (0, exports.AvatarsApiFp)(this.configuration).getFavoritedAvatars(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get the current avatar for the user. This will return an error for any other user than the one logged in.
     * @summary Get Own Avatar
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    AvatarsApi.prototype.getOwnAvatar = function (userId, options) {
        var _this = this;
        return (0, exports.AvatarsApiFp)(this.configuration).getOwnAvatar(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
     * @summary Search Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    AvatarsApi.prototype.searchAvatars = function (featured, sort, user, userId, n, order, offset, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
        var _this = this;
        return (0, exports.AvatarsApiFp)(this.configuration).searchAvatars(featured, sort, user, userId, n, order, offset, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Switches into that avatar.
     * @summary Select Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    AvatarsApi.prototype.selectAvatar = function (avatarId, options) {
        var _this = this;
        return (0, exports.AvatarsApiFp)(this.configuration).selectAvatar(avatarId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Switches into that avatar as your fallback avatar.
     * @summary Select Fallback Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    AvatarsApi.prototype.selectFallbackAvatar = function (avatarId, options) {
        var _this = this;
        return (0, exports.AvatarsApiFp)(this.configuration).selectFallbackAvatar(avatarId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update information about a specific avatar.
     * @summary Update Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {UpdateAvatarRequest} [updateAvatarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    AvatarsApi.prototype.updateAvatar = function (avatarId, updateAvatarRequest, options) {
        var _this = this;
        return (0, exports.AvatarsApiFp)(this.configuration).updateAvatar(avatarId, updateAvatarRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AvatarsApi;
}(base_1.BaseAPI));
exports.AvatarsApi = AvatarsApi;
/**
 * EconomyApi - axios parameter creator
 * @export
 */
var EconomyApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Get a list of all current user subscriptions.
         * @summary Get Current Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSubscriptions: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/user/subscription";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get a single License Group by given ID.
         * @summary Get License Group
         * @param {string} licenseGroupId Must be a valid license group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseGroup: function (licenseGroupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'licenseGroupId' is not null or undefined
                    (0, common_1.assertParamExists)('getLicenseGroup', 'licenseGroupId', licenseGroupId);
                    localVarPath = "/licenseGroups/{licenseGroupId}"
                        .replace("{".concat("licenseGroupId", "}"), encodeURIComponent(String(licenseGroupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
         * @summary Get Steam Transaction
         * @param {string} transactionId Must be a valid transaction ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSteamTransaction: function (transactionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'transactionId' is not null or undefined
                    (0, common_1.assertParamExists)('getSteamTransaction', 'transactionId', transactionId);
                    localVarPath = "/Steam/transactions/{transactionId}"
                        .replace("{".concat("transactionId", "}"), encodeURIComponent(String(transactionId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get all own Steam transactions.
         * @summary List Steam Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSteamTransactions: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/Steam/transactions";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
         * @summary List Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/subscriptions";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.EconomyApiAxiosParamCreator = EconomyApiAxiosParamCreator;
/**
 * EconomyApi - functional programming interface
 * @export
 */
var EconomyApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.EconomyApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get a list of all current user subscriptions.
         * @summary Get Current Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSubscriptions: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCurrentSubscriptions(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get a single License Group by given ID.
         * @summary Get License Group
         * @param {string} licenseGroupId Must be a valid license group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseGroup: function (licenseGroupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLicenseGroup(licenseGroupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
         * @summary Get Steam Transaction
         * @param {string} transactionId Must be a valid transaction ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSteamTransaction: function (transactionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSteamTransaction(transactionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get all own Steam transactions.
         * @summary List Steam Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSteamTransactions: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSteamTransactions(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
         * @summary List Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSubscriptions(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.EconomyApiFp = EconomyApiFp;
/**
 * EconomyApi - factory interface
 * @export
 */
var EconomyApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.EconomyApiFp)(configuration);
    return {
        /**
         * Get a list of all current user subscriptions.
         * @summary Get Current Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSubscriptions: function (options) {
            return localVarFp.getCurrentSubscriptions(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get a single License Group by given ID.
         * @summary Get License Group
         * @param {string} licenseGroupId Must be a valid license group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseGroup: function (licenseGroupId, options) {
            return localVarFp.getLicenseGroup(licenseGroupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
         * @summary Get Steam Transaction
         * @param {string} transactionId Must be a valid transaction ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getSteamTransaction: function (transactionId, options) {
            return localVarFp.getSteamTransaction(transactionId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get all own Steam transactions.
         * @summary List Steam Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSteamTransactions: function (options) {
            return localVarFp.getSteamTransactions(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
         * @summary List Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions: function (options) {
            return localVarFp.getSubscriptions(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.EconomyApiFactory = EconomyApiFactory;
/**
 * EconomyApi - object-oriented interface
 * @export
 * @class EconomyApi
 * @extends {BaseAPI}
 */
var EconomyApi = /** @class */ (function (_super) {
    __extends(EconomyApi, _super);
    function EconomyApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get a list of all current user subscriptions.
     * @summary Get Current Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    EconomyApi.prototype.getCurrentSubscriptions = function (options) {
        var _this = this;
        return (0, exports.EconomyApiFp)(this.configuration).getCurrentSubscriptions(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get a single License Group by given ID.
     * @summary Get License Group
     * @param {string} licenseGroupId Must be a valid license group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    EconomyApi.prototype.getLicenseGroup = function (licenseGroupId, options) {
        var _this = this;
        return (0, exports.EconomyApiFp)(this.configuration).getLicenseGroup(licenseGroupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
     * @summary Get Steam Transaction
     * @param {string} transactionId Must be a valid transaction ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    EconomyApi.prototype.getSteamTransaction = function (transactionId, options) {
        var _this = this;
        return (0, exports.EconomyApiFp)(this.configuration).getSteamTransaction(transactionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get all own Steam transactions.
     * @summary List Steam Transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    EconomyApi.prototype.getSteamTransactions = function (options) {
        var _this = this;
        return (0, exports.EconomyApiFp)(this.configuration).getSteamTransactions(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
     * @summary List Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    EconomyApi.prototype.getSubscriptions = function (options) {
        var _this = this;
        return (0, exports.EconomyApiFp)(this.configuration).getSubscriptions(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return EconomyApi;
}(base_1.BaseAPI));
exports.EconomyApi = EconomyApi;
/**
 * FavoritesApi - axios parameter creator
 * @export
 */
var FavoritesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
         * @summary Add Favorite
         * @param {AddFavoriteRequest} [addFavoriteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFavorite: function (addFavoriteRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/favorites";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addFavoriteRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Clear ALL contents of a specific favorite group.
         * @summary Clear Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearFavoriteGroup: function (favoriteGroupType, favoriteGroupName, userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'favoriteGroupType' is not null or undefined
                    (0, common_1.assertParamExists)('clearFavoriteGroup', 'favoriteGroupType', favoriteGroupType);
                    // verify required parameter 'favoriteGroupName' is not null or undefined
                    (0, common_1.assertParamExists)('clearFavoriteGroup', 'favoriteGroupName', favoriteGroupName);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('clearFavoriteGroup', 'userId', userId);
                    localVarPath = "/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}"
                        .replace("{".concat("favoriteGroupType", "}"), encodeURIComponent(String(favoriteGroupType)))
                        .replace("{".concat("favoriteGroupName", "}"), encodeURIComponent(String(favoriteGroupName)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return information about a specific Favorite.
         * @summary Show Favorite
         * @param {string} favoriteId Must be a valid favorite ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorite: function (favoriteId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'favoriteId' is not null or undefined
                    (0, common_1.assertParamExists)('getFavorite', 'favoriteId', favoriteId);
                    localVarPath = "/favorites/{favoriteId}"
                        .replace("{".concat("favoriteId", "}"), encodeURIComponent(String(favoriteId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Fetch information about a specific favorite group.
         * @summary Show Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteGroup: function (favoriteGroupType, favoriteGroupName, userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'favoriteGroupType' is not null or undefined
                    (0, common_1.assertParamExists)('getFavoriteGroup', 'favoriteGroupType', favoriteGroupType);
                    // verify required parameter 'favoriteGroupName' is not null or undefined
                    (0, common_1.assertParamExists)('getFavoriteGroup', 'favoriteGroupName', favoriteGroupName);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('getFavoriteGroup', 'userId', userId);
                    localVarPath = "/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}"
                        .replace("{".concat("favoriteGroupType", "}"), encodeURIComponent(String(favoriteGroupType)))
                        .replace("{".concat("favoriteGroupName", "}"), encodeURIComponent(String(favoriteGroupName)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
         * @summary List Favorite Groups
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteGroups: function (n, offset, ownerId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/favorite/groups";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (ownerId !== undefined) {
                        localVarQueryParameter['ownerId'] = ownerId;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a list of favorites.
         * @summary List Favorites
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [type] The type of favorites to return, FavoriteType.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorites: function (n, offset, type, tag, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/favorites";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (type !== undefined) {
                        localVarQueryParameter['type'] = type;
                    }
                    if (tag !== undefined) {
                        localVarQueryParameter['tag'] = tag;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Remove a favorite from your favorites list.
         * @summary Remove Favorite
         * @param {string} favoriteId Must be a valid favorite ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFavorite: function (favoriteId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'favoriteId' is not null or undefined
                    (0, common_1.assertParamExists)('removeFavorite', 'favoriteId', favoriteId);
                    localVarPath = "/favorites/{favoriteId}"
                        .replace("{".concat("favoriteId", "}"), encodeURIComponent(String(favoriteId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Update information about a specific favorite group.
         * @summary Update Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFavoriteGroup: function (favoriteGroupType, favoriteGroupName, userId, updateFavoriteGroupRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'favoriteGroupType' is not null or undefined
                    (0, common_1.assertParamExists)('updateFavoriteGroup', 'favoriteGroupType', favoriteGroupType);
                    // verify required parameter 'favoriteGroupName' is not null or undefined
                    (0, common_1.assertParamExists)('updateFavoriteGroup', 'favoriteGroupName', favoriteGroupName);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('updateFavoriteGroup', 'userId', userId);
                    localVarPath = "/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}"
                        .replace("{".concat("favoriteGroupType", "}"), encodeURIComponent(String(favoriteGroupType)))
                        .replace("{".concat("favoriteGroupName", "}"), encodeURIComponent(String(favoriteGroupName)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateFavoriteGroupRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.FavoritesApiAxiosParamCreator = FavoritesApiAxiosParamCreator;
/**
 * FavoritesApi - functional programming interface
 * @export
 */
var FavoritesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.FavoritesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
         * @summary Add Favorite
         * @param {AddFavoriteRequest} [addFavoriteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFavorite: function (addFavoriteRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.addFavorite(addFavoriteRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Clear ALL contents of a specific favorite group.
         * @summary Clear Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearFavoriteGroup: function (favoriteGroupType, favoriteGroupName, userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.clearFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Return information about a specific Favorite.
         * @summary Show Favorite
         * @param {string} favoriteId Must be a valid favorite ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorite: function (favoriteId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFavorite(favoriteId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fetch information about a specific favorite group.
         * @summary Show Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteGroup: function (favoriteGroupType, favoriteGroupName, userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
         * @summary List Favorite Groups
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteGroups: function (n, offset, ownerId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFavoriteGroups(n, offset, ownerId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of favorites.
         * @summary List Favorites
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [type] The type of favorites to return, FavoriteType.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorites: function (n, offset, type, tag, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFavorites(n, offset, type, tag, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Remove a favorite from your favorites list.
         * @summary Remove Favorite
         * @param {string} favoriteId Must be a valid favorite ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFavorite: function (favoriteId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.removeFavorite(favoriteId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update information about a specific favorite group.
         * @summary Update Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFavoriteGroup: function (favoriteGroupType, favoriteGroupName, userId, updateFavoriteGroupRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, updateFavoriteGroupRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.FavoritesApiFp = FavoritesApiFp;
/**
 * FavoritesApi - factory interface
 * @export
 */
var FavoritesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.FavoritesApiFp)(configuration);
    return {
        /**
         * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
         * @summary Add Favorite
         * @param {AddFavoriteRequest} [addFavoriteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFavorite: function (addFavoriteRequest, options) {
            return localVarFp.addFavorite(addFavoriteRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Clear ALL contents of a specific favorite group.
         * @summary Clear Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearFavoriteGroup: function (favoriteGroupType, favoriteGroupName, userId, options) {
            return localVarFp.clearFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return information about a specific Favorite.
         * @summary Show Favorite
         * @param {string} favoriteId Must be a valid favorite ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorite: function (favoriteId, options) {
            return localVarFp.getFavorite(favoriteId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fetch information about a specific favorite group.
         * @summary Show Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteGroup: function (favoriteGroupType, favoriteGroupName, userId, options) {
            return localVarFp.getFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
         * @summary List Favorite Groups
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteGroups: function (n, offset, ownerId, options) {
            return localVarFp.getFavoriteGroups(n, offset, ownerId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of favorites.
         * @summary List Favorites
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [type] The type of favorites to return, FavoriteType.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorites: function (n, offset, type, tag, options) {
            return localVarFp.getFavorites(n, offset, type, tag, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Remove a favorite from your favorites list.
         * @summary Remove Favorite
         * @param {string} favoriteId Must be a valid favorite ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFavorite: function (favoriteId, options) {
            return localVarFp.removeFavorite(favoriteId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update information about a specific favorite group.
         * @summary Update Favorite Group
         * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
         * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFavoriteGroup: function (favoriteGroupType, favoriteGroupName, userId, updateFavoriteGroupRequest, options) {
            return localVarFp.updateFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, updateFavoriteGroupRequest, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.FavoritesApiFactory = FavoritesApiFactory;
/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
var FavoritesApi = /** @class */ (function (_super) {
    __extends(FavoritesApi, _super);
    function FavoritesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
     * @summary Add Favorite
     * @param {AddFavoriteRequest} [addFavoriteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    FavoritesApi.prototype.addFavorite = function (addFavoriteRequest, options) {
        var _this = this;
        return (0, exports.FavoritesApiFp)(this.configuration).addFavorite(addFavoriteRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Clear ALL contents of a specific favorite group.
     * @summary Clear Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    FavoritesApi.prototype.clearFavoriteGroup = function (favoriteGroupType, favoriteGroupName, userId, options) {
        var _this = this;
        return (0, exports.FavoritesApiFp)(this.configuration).clearFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Return information about a specific Favorite.
     * @summary Show Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    FavoritesApi.prototype.getFavorite = function (favoriteId, options) {
        var _this = this;
        return (0, exports.FavoritesApiFp)(this.configuration).getFavorite(favoriteId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fetch information about a specific favorite group.
     * @summary Show Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    FavoritesApi.prototype.getFavoriteGroup = function (favoriteGroupType, favoriteGroupName, userId, options) {
        var _this = this;
        return (0, exports.FavoritesApiFp)(this.configuration).getFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
     * @summary List Favorite Groups
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    FavoritesApi.prototype.getFavoriteGroups = function (n, offset, ownerId, options) {
        var _this = this;
        return (0, exports.FavoritesApiFp)(this.configuration).getFavoriteGroups(n, offset, ownerId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of favorites.
     * @summary List Favorites
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [type] The type of favorites to return, FavoriteType.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    FavoritesApi.prototype.getFavorites = function (n, offset, type, tag, options) {
        var _this = this;
        return (0, exports.FavoritesApiFp)(this.configuration).getFavorites(n, offset, type, tag, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Remove a favorite from your favorites list.
     * @summary Remove Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    FavoritesApi.prototype.removeFavorite = function (favoriteId, options) {
        var _this = this;
        return (0, exports.FavoritesApiFp)(this.configuration).removeFavorite(favoriteId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update information about a specific favorite group.
     * @summary Update Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    FavoritesApi.prototype.updateFavoriteGroup = function (favoriteGroupType, favoriteGroupName, userId, updateFavoriteGroupRequest, options) {
        var _this = this;
        return (0, exports.FavoritesApiFp)(this.configuration).updateFavoriteGroup(favoriteGroupType, favoriteGroupName, userId, updateFavoriteGroupRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return FavoritesApi;
}(base_1.BaseAPI));
exports.FavoritesApi = FavoritesApi;
/**
 * FilesApi - axios parameter creator
 * @export
 */
var FilesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Creates a new File object
         * @summary Create File
         * @param {CreateFileRequest} [createFileRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: function (createFileRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/file";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFileRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
         * @summary Create File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {CreateFileVersionRequest} [createFileVersionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileVersion: function (fileId, createFileVersionRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'fileId' is not null or undefined
                    (0, common_1.assertParamExists)('createFileVersion', 'fileId', fileId);
                    localVarPath = "/file/{fileId}"
                        .replace("{".concat("fileId", "}"), encodeURIComponent(String(fileId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFileVersionRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Deletes a File object.
         * @summary Delete File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: function (fileId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'fileId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteFile', 'fileId', fileId);
                    localVarPath = "/file/{fileId}"
                        .replace("{".concat("fileId", "}"), encodeURIComponent(String(fileId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Delete a specific version of a file. You can only delete the latest version.
         * @summary Delete File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileVersion: function (fileId, versionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'fileId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteFileVersion', 'fileId', fileId);
                    // verify required parameter 'versionId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteFileVersion', 'versionId', versionId);
                    localVarPath = "/file/{fileId}/{versionId}"
                        .replace("{".concat("fileId", "}"), encodeURIComponent(String(fileId)))
                        .replace("{".concat("versionId", "}"), encodeURIComponent(String(versionId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
         * @summary Download File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFileVersion: function (fileId, versionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'fileId' is not null or undefined
                    (0, common_1.assertParamExists)('downloadFileVersion', 'fileId', fileId);
                    // verify required parameter 'versionId' is not null or undefined
                    (0, common_1.assertParamExists)('downloadFileVersion', 'versionId', versionId);
                    localVarPath = "/file/{fileId}/{versionId}"
                        .replace("{".concat("fileId", "}"), encodeURIComponent(String(fileId)))
                        .replace("{".concat("versionId", "}"), encodeURIComponent(String(versionId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
         * @summary Finish FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishFileDataUpload: function (fileId, versionId, fileType, finishFileDataUploadRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'fileId' is not null or undefined
                    (0, common_1.assertParamExists)('finishFileDataUpload', 'fileId', fileId);
                    // verify required parameter 'versionId' is not null or undefined
                    (0, common_1.assertParamExists)('finishFileDataUpload', 'versionId', versionId);
                    // verify required parameter 'fileType' is not null or undefined
                    (0, common_1.assertParamExists)('finishFileDataUpload', 'fileType', fileType);
                    localVarPath = "/file/{fileId}/{versionId}/{fileType}/finish"
                        .replace("{".concat("fileId", "}"), encodeURIComponent(String(fileId)))
                        .replace("{".concat("versionId", "}"), encodeURIComponent(String(versionId)))
                        .replace("{".concat("fileType", "}"), encodeURIComponent(String(fileType)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(finishFileDataUploadRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
         * @summary Show File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: function (fileId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'fileId' is not null or undefined
                    (0, common_1.assertParamExists)('getFile', 'fileId', fileId);
                    localVarPath = "/file/{fileId}"
                        .replace("{".concat("fileId", "}"), encodeURIComponent(String(fileId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
         * @summary Check FileData Upload Status
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileDataUploadStatus: function (fileId, versionId, fileType, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'fileId' is not null or undefined
                    (0, common_1.assertParamExists)('getFileDataUploadStatus', 'fileId', fileId);
                    // verify required parameter 'versionId' is not null or undefined
                    (0, common_1.assertParamExists)('getFileDataUploadStatus', 'versionId', versionId);
                    // verify required parameter 'fileType' is not null or undefined
                    (0, common_1.assertParamExists)('getFileDataUploadStatus', 'fileType', fileType);
                    localVarPath = "/file/{fileId}/{versionId}/{fileType}/status"
                        .replace("{".concat("fileId", "}"), encodeURIComponent(String(fileId)))
                        .replace("{".concat("versionId", "}"), encodeURIComponent(String(versionId)))
                        .replace("{".concat("fileType", "}"), encodeURIComponent(String(fileType)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a list of files
         * @summary List Files
         * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
         * @param {string} [userId] UserID, will always generate a 500 permission error.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles: function (tag, userId, n, offset, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/files";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (tag !== undefined) {
                        localVarQueryParameter['tag'] = tag;
                    }
                    if (userId !== undefined) {
                        localVarQueryParameter['userId'] = userId;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
         * @summary Start FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFileDataUpload: function (fileId, versionId, fileType, partNumber, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'fileId' is not null or undefined
                    (0, common_1.assertParamExists)('startFileDataUpload', 'fileId', fileId);
                    // verify required parameter 'versionId' is not null or undefined
                    (0, common_1.assertParamExists)('startFileDataUpload', 'versionId', versionId);
                    // verify required parameter 'fileType' is not null or undefined
                    (0, common_1.assertParamExists)('startFileDataUpload', 'fileType', fileType);
                    localVarPath = "/file/{fileId}/{versionId}/{fileType}/start"
                        .replace("{".concat("fileId", "}"), encodeURIComponent(String(fileId)))
                        .replace("{".concat("versionId", "}"), encodeURIComponent(String(versionId)))
                        .replace("{".concat("fileType", "}"), encodeURIComponent(String(fileType)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (partNumber !== undefined) {
                        localVarQueryParameter['partNumber'] = partNumber;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.FilesApiAxiosParamCreator = FilesApiAxiosParamCreator;
/**
 * FilesApi - functional programming interface
 * @export
 */
var FilesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.FilesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a new File object
         * @summary Create File
         * @param {CreateFileRequest} [createFileRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: function (createFileRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createFile(createFileRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
         * @summary Create File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {CreateFileVersionRequest} [createFileVersionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileVersion: function (fileId, createFileVersionRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createFileVersion(fileId, createFileVersionRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes a File object.
         * @summary Delete File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: function (fileId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteFile(fileId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Delete a specific version of a file. You can only delete the latest version.
         * @summary Delete File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileVersion: function (fileId, versionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteFileVersion(fileId, versionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
         * @summary Download File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFileVersion: function (fileId, versionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.downloadFileVersion(fileId, versionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
         * @summary Finish FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishFileDataUpload: function (fileId, versionId, fileType, finishFileDataUploadRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.finishFileDataUpload(fileId, versionId, fileType, finishFileDataUploadRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
         * @summary Show File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: function (fileId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFile(fileId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
         * @summary Check FileData Upload Status
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileDataUploadStatus: function (fileId, versionId, fileType, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFileDataUploadStatus(fileId, versionId, fileType, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of files
         * @summary List Files
         * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
         * @param {string} [userId] UserID, will always generate a 500 permission error.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles: function (tag, userId, n, offset, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFiles(tag, userId, n, offset, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
         * @summary Start FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFileDataUpload: function (fileId, versionId, fileType, partNumber, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startFileDataUpload(fileId, versionId, fileType, partNumber, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.FilesApiFp = FilesApiFp;
/**
 * FilesApi - factory interface
 * @export
 */
var FilesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.FilesApiFp)(configuration);
    return {
        /**
         * Creates a new File object
         * @summary Create File
         * @param {CreateFileRequest} [createFileRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: function (createFileRequest, options) {
            return localVarFp.createFile(createFileRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
         * @summary Create File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {CreateFileVersionRequest} [createFileVersionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileVersion: function (fileId, createFileVersionRequest, options) {
            return localVarFp.createFileVersion(fileId, createFileVersionRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes a File object.
         * @summary Delete File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: function (fileId, options) {
            return localVarFp.deleteFile(fileId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete a specific version of a file. You can only delete the latest version.
         * @summary Delete File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileVersion: function (fileId, versionId, options) {
            return localVarFp.deleteFileVersion(fileId, versionId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
         * @summary Download File Version
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFileVersion: function (fileId, versionId, options) {
            return localVarFp.downloadFileVersion(fileId, versionId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
         * @summary Finish FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishFileDataUpload: function (fileId, versionId, fileType, finishFileDataUploadRequest, options) {
            return localVarFp.finishFileDataUpload(fileId, versionId, fileType, finishFileDataUploadRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
         * @summary Show File
         * @param {string} fileId Must be a valid file ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: function (fileId, options) {
            return localVarFp.getFile(fileId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
         * @summary Check FileData Upload Status
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileDataUploadStatus: function (fileId, versionId, fileType, options) {
            return localVarFp.getFileDataUploadStatus(fileId, versionId, fileType, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of files
         * @summary List Files
         * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
         * @param {string} [userId] UserID, will always generate a 500 permission error.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles: function (tag, userId, n, offset, options) {
            return localVarFp.getFiles(tag, userId, n, offset, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
         * @summary Start FileData Upload
         * @param {string} fileId Must be a valid file ID.
         * @param {number} versionId Version ID of the asset.
         * @param {'file' | 'signature' | 'delta'} fileType Type of file.
         * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFileDataUpload: function (fileId, versionId, fileType, partNumber, options) {
            return localVarFp.startFileDataUpload(fileId, versionId, fileType, partNumber, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.FilesApiFactory = FilesApiFactory;
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
var FilesApi = /** @class */ (function (_super) {
    __extends(FilesApi, _super);
    function FilesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a new File object
     * @summary Create File
     * @param {CreateFileRequest} [createFileRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    FilesApi.prototype.createFile = function (createFileRequest, options) {
        var _this = this;
        return (0, exports.FilesApiFp)(this.configuration).createFile(createFileRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
     * @summary Create File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {CreateFileVersionRequest} [createFileVersionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    FilesApi.prototype.createFileVersion = function (fileId, createFileVersionRequest, options) {
        var _this = this;
        return (0, exports.FilesApiFp)(this.configuration).createFileVersion(fileId, createFileVersionRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes a File object.
     * @summary Delete File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    FilesApi.prototype.deleteFile = function (fileId, options) {
        var _this = this;
        return (0, exports.FilesApiFp)(this.configuration).deleteFile(fileId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Delete a specific version of a file. You can only delete the latest version.
     * @summary Delete File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    FilesApi.prototype.deleteFileVersion = function (fileId, versionId, options) {
        var _this = this;
        return (0, exports.FilesApiFp)(this.configuration).deleteFileVersion(fileId, versionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
     * @summary Download File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    FilesApi.prototype.downloadFileVersion = function (fileId, versionId, options) {
        var _this = this;
        return (0, exports.FilesApiFp)(this.configuration).downloadFileVersion(fileId, versionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
     * @summary Finish FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    FilesApi.prototype.finishFileDataUpload = function (fileId, versionId, fileType, finishFileDataUploadRequest, options) {
        var _this = this;
        return (0, exports.FilesApiFp)(this.configuration).finishFileDataUpload(fileId, versionId, fileType, finishFileDataUploadRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
     * @summary Show File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    FilesApi.prototype.getFile = function (fileId, options) {
        var _this = this;
        return (0, exports.FilesApiFp)(this.configuration).getFile(fileId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
     * @summary Check FileData Upload Status
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    FilesApi.prototype.getFileDataUploadStatus = function (fileId, versionId, fileType, options) {
        var _this = this;
        return (0, exports.FilesApiFp)(this.configuration).getFileDataUploadStatus(fileId, versionId, fileType, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of files
     * @summary List Files
     * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
     * @param {string} [userId] UserID, will always generate a 500 permission error.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    FilesApi.prototype.getFiles = function (tag, userId, n, offset, options) {
        var _this = this;
        return (0, exports.FilesApiFp)(this.configuration).getFiles(tag, userId, n, offset, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     * @summary Start FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    FilesApi.prototype.startFileDataUpload = function (fileId, versionId, fileType, partNumber, options) {
        var _this = this;
        return (0, exports.FilesApiFp)(this.configuration).startFileDataUpload(fileId, versionId, fileType, partNumber, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return FilesApi;
}(base_1.BaseAPI));
exports.FilesApi = FilesApi;
/**
 * FriendsApi - axios parameter creator
 * @export
 */
var FriendsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
         * @summary Delete Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFriendRequest: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteFriendRequest', 'userId', userId);
                    localVarPath = "/user/{userId}/friendRequest"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Send a friend request to another user.
         * @summary Send Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friend: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('friend', 'userId', userId);
                    localVarPath = "/user/{userId}/friendRequest"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
         * @summary Check Friend Status
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendStatus: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('getFriendStatus', 'userId', userId);
                    localVarPath = "/user/{userId}/friendStatus"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * List information about friends.
         * @summary List Friends
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends: function (offset, n, offline, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/user/friends";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (offline !== undefined) {
                        localVarQueryParameter['offline'] = offline;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Unfriend a user by ID.
         * @summary Unfriend
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfriend: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('unfriend', 'userId', userId);
                    localVarPath = "/auth/user/friends/{userId}"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.FriendsApiAxiosParamCreator = FriendsApiAxiosParamCreator;
/**
 * FriendsApi - functional programming interface
 * @export
 */
var FriendsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.FriendsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
         * @summary Delete Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFriendRequest: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteFriendRequest(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Send a friend request to another user.
         * @summary Send Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friend: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.friend(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
         * @summary Check Friend Status
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendStatus: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFriendStatus(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * List information about friends.
         * @summary List Friends
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends: function (offset, n, offline, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFriends(offset, n, offline, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Unfriend a user by ID.
         * @summary Unfriend
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfriend: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unfriend(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.FriendsApiFp = FriendsApiFp;
/**
 * FriendsApi - factory interface
 * @export
 */
var FriendsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.FriendsApiFp)(configuration);
    return {
        /**
         * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
         * @summary Delete Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFriendRequest: function (userId, options) {
            return localVarFp.deleteFriendRequest(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Send a friend request to another user.
         * @summary Send Friend Request
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        friend: function (userId, options) {
            return localVarFp.friend(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
         * @summary Check Friend Status
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriendStatus: function (userId, options) {
            return localVarFp.getFriendStatus(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * List information about friends.
         * @summary List Friends
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends: function (offset, n, offline, options) {
            return localVarFp.getFriends(offset, n, offline, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Unfriend a user by ID.
         * @summary Unfriend
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfriend: function (userId, options) {
            return localVarFp.unfriend(userId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.FriendsApiFactory = FriendsApiFactory;
/**
 * FriendsApi - object-oriented interface
 * @export
 * @class FriendsApi
 * @extends {BaseAPI}
 */
var FriendsApi = /** @class */ (function (_super) {
    __extends(FriendsApi, _super);
    function FriendsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
     * @summary Delete Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    FriendsApi.prototype.deleteFriendRequest = function (userId, options) {
        var _this = this;
        return (0, exports.FriendsApiFp)(this.configuration).deleteFriendRequest(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Send a friend request to another user.
     * @summary Send Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    FriendsApi.prototype.friend = function (userId, options) {
        var _this = this;
        return (0, exports.FriendsApiFp)(this.configuration).friend(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
     * @summary Check Friend Status
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    FriendsApi.prototype.getFriendStatus = function (userId, options) {
        var _this = this;
        return (0, exports.FriendsApiFp)(this.configuration).getFriendStatus(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * List information about friends.
     * @summary List Friends
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {number} [n] The number of objects to return.
     * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    FriendsApi.prototype.getFriends = function (offset, n, offline, options) {
        var _this = this;
        return (0, exports.FriendsApiFp)(this.configuration).getFriends(offset, n, offline, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Unfriend a user by ID.
     * @summary Unfriend
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    FriendsApi.prototype.unfriend = function (userId, options) {
        var _this = this;
        return (0, exports.FriendsApiFp)(this.configuration).unfriend(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return FriendsApi;
}(base_1.BaseAPI));
exports.FriendsApi = FriendsApi;
/**
 * GroupsApi - axios parameter creator
 * @export
 */
var GroupsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Adds an image to a Group gallery.
         * @summary Add Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {AddGroupGalleryImageRequest} [addGroupGalleryImageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupGalleryImage: function (groupId, groupGalleryId, addGroupGalleryImageRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('addGroupGalleryImage', 'groupId', groupId);
                    // verify required parameter 'groupGalleryId' is not null or undefined
                    (0, common_1.assertParamExists)('addGroupGalleryImage', 'groupGalleryId', groupGalleryId);
                    localVarPath = "/groups/{groupId}/galleries/{groupGalleryId}/images"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("groupGalleryId", "}"), encodeURIComponent(String(groupGalleryId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addGroupGalleryImageRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Adds a Role to a Group Member
         * @summary Add Role to GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMemberRole: function (groupId, userId, groupRoleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('addGroupMemberRole', 'groupId', groupId);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('addGroupMemberRole', 'userId', userId);
                    // verify required parameter 'groupRoleId' is not null or undefined
                    (0, common_1.assertParamExists)('addGroupMemberRole', 'groupRoleId', groupRoleId);
                    localVarPath = "/groups/{groupId}/members/{userId}/roles/{groupRoleId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)))
                        .replace("{".concat("groupRoleId", "}"), encodeURIComponent(String(groupRoleId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Bans a user from a Group.
         * @summary Ban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {BanGroupMemberRequest} [banGroupMemberRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banGroupMember: function (groupId, banGroupMemberRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('banGroupMember', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/bans"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(banGroupMemberRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Cancels a request sent to join the group.
         * @summary Cancel Group Join Request
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupRequest: function (groupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('cancelGroupRequest', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/requests"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
         * @summary Create Group
         * @param {CreateGroupRequest} [createGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: function (createGroupRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/groups";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createGroupRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Creates an Announcement for a Group.
         * @summary Create Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupAnnouncementRequest} [createGroupAnnouncementRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupAnnouncement: function (groupId, createGroupAnnouncementRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('createGroupAnnouncement', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/announcement"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createGroupAnnouncementRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Creates a gallery for a Group.
         * @summary Create Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupGalleryRequest} [createGroupGalleryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupGallery: function (groupId, createGroupGalleryRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('createGroupGallery', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/galleries"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createGroupGalleryRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Sends an invite to a user to join the group.
         * @summary Invite User to Group
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupInviteRequest} [createGroupInviteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupInvite: function (groupId, createGroupInviteRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('createGroupInvite', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/invites"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createGroupInviteRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Create a Group role.
         * @summary Create GroupRole
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupRoleRequest} [createGroupRoleRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupRole: function (groupId, createGroupRoleRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('createGroupRole', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/roles"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createGroupRoleRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Deletes a Group.
         * @summary Delete Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: function (groupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroup', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Deletes the announcement for a Group.
         * @summary Delete Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupAnnouncement: function (groupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroupAnnouncement', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/announcement"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Deletes a gallery for a Group.
         * @summary Delete Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupGallery: function (groupId, groupGalleryId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroupGallery', 'groupId', groupId);
                    // verify required parameter 'groupGalleryId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroupGallery', 'groupGalleryId', groupGalleryId);
                    localVarPath = "/groups/{groupId}/galleries/{groupGalleryId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("groupGalleryId", "}"), encodeURIComponent(String(groupGalleryId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Deletes an image from a Group gallery.
         * @summary Delete Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupGalleryImage: function (groupId, groupGalleryId, groupGalleryImageId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroupGalleryImage', 'groupId', groupId);
                    // verify required parameter 'groupGalleryId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroupGalleryImage', 'groupGalleryId', groupGalleryId);
                    // verify required parameter 'groupGalleryImageId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroupGalleryImage', 'groupGalleryImageId', groupGalleryImageId);
                    localVarPath = "/groups/{groupId}/galleries/{groupGalleryId}/images/{groupGalleryImageId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("groupGalleryId", "}"), encodeURIComponent(String(groupGalleryId)))
                        .replace("{".concat("groupGalleryImageId", "}"), encodeURIComponent(String(groupGalleryImageId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Deletes an Group invite sent to a User
         * @summary Delete User Invite
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupInvite: function (groupId, userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroupInvite', 'groupId', groupId);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroupInvite', 'userId', userId);
                    localVarPath = "/groups/{groupId}/invites/{userId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Deletes a Group Role by ID and returns the remaining roles.
         * @summary Delete Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupRole: function (groupId, groupRoleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroupRole', 'groupId', groupId);
                    // verify required parameter 'groupRoleId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteGroupRole', 'groupRoleId', groupRoleId);
                    localVarPath = "/groups/{groupId}/roles/{groupRoleId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("groupRoleId", "}"), encodeURIComponent(String(groupRoleId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a single Group by ID.
         * @summary Get Group by ID
         * @param {string} groupId Must be a valid group ID.
         * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: function (groupId, includeRoles, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroup', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (includeRoles !== undefined) {
                        localVarQueryParameter['includeRoles'] = includeRoles;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
         * @summary Get Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAnnouncements: function (groupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupAnnouncements', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/announcement"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a list of audit logs for a Group.
         * @summary Get Group Audit Logs
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [startDate] The start date of the search range.
         * @param {string} [endDate] The end date of the search range.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAuditLogs: function (groupId, n, offset, startDate, endDate, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupAuditLogs', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/auditLogs"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (startDate !== undefined) {
                        localVarQueryParameter['startDate'] = (startDate instanceof Date) ?
                            startDate.toISOString() :
                            startDate;
                    }
                    if (endDate !== undefined) {
                        localVarQueryParameter['endDate'] = (endDate instanceof Date) ?
                            endDate.toISOString() :
                            endDate;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a list of banned users for a Group.
         * @summary Get Group Bans
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupBans: function (groupId, n, offset, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupBans', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/bans"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a list of images for a Group gallery.
         * @summary Get Group Gallery Images
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupGalleryImages: function (groupId, groupGalleryId, n, offset, approved, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupGalleryImages', 'groupId', groupId);
                    // verify required parameter 'groupGalleryId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupGalleryImages', 'groupGalleryId', groupGalleryId);
                    localVarPath = "/groups/{groupId}/galleries/{groupGalleryId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("groupGalleryId", "}"), encodeURIComponent(String(groupGalleryId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (approved !== undefined) {
                        localVarQueryParameter['approved'] = approved;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a list of members that have been invited to the Group.
         * @summary Get Group Invites Sent
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupInvites: function (groupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupInvites', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/invites"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a LimitedGroup Member.
         * @summary Get Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMember: function (groupId, userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupMember', 'groupId', groupId);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupMember', 'userId', userId);
                    localVarPath = "/groups/{groupId}/members/{userId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
         * @summary List Group Members
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {GroupSearchSort} [sort] The sort order of Group Member results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers: function (groupId, n, offset, sort, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupMembers', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/members"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (sort !== undefined) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a List of all possible/available permissions for a Group.
         * @summary List Group Permissions
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissions: function (groupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupPermissions', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/permissions"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a list of members that have requested to join the Group.
         * @summary Get Group Join Requests
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRequests: function (groupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupRequests', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/requests"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a Group Role by ID.
         * @summary Get Group Roles
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRoles: function (groupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('getGroupRoles', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/roles"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Join a Group by ID and returns the member object.
         * @summary Join Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroup: function (groupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('joinGroup', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/join"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
         * @summary Kick Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickGroupMember: function (groupId, userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('kickGroupMember', 'groupId', groupId);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('kickGroupMember', 'userId', userId);
                    localVarPath = "/groups/{groupId}/members/{userId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Leave a group by ID.
         * @summary Leave Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroup: function (groupId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('leaveGroup', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}/leave"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Removes a Role from a Group Member
         * @summary Remove Role from GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGroupMemberRole: function (groupId, userId, groupRoleId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('removeGroupMemberRole', 'groupId', groupId);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('removeGroupMemberRole', 'userId', userId);
                    // verify required parameter 'groupRoleId' is not null or undefined
                    (0, common_1.assertParamExists)('removeGroupMemberRole', 'groupRoleId', groupRoleId);
                    localVarPath = "/groups/{groupId}/members/{userId}/roles/{groupRoleId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)))
                        .replace("{".concat("groupRoleId", "}"), encodeURIComponent(String(groupRoleId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Responds to a Group Join Request with Accept/Deny
         * @summary Respond Group Join request
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {RespondGroupJoinRequest} [respondGroupJoinRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondGroupJoinRequest: function (groupId, userId, respondGroupJoinRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('respondGroupJoinRequest', 'groupId', groupId);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('respondGroupJoinRequest', 'userId', userId);
                    localVarPath = "/groups/{groupId}/requests/{userId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(respondGroupJoinRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Searches Groups by name or shortCode
         * @summary Search Group
         * @param {string} [query] Query to search for, can be either Group Name or Group shortCode
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroups: function (query, offset, n, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/groups";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (query !== undefined) {
                        localVarQueryParameter['query'] = query;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Unbans a user from a Group.
         * @summary Unban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanGroupMember: function (groupId, userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('unbanGroupMember', 'groupId', groupId);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('unbanGroupMember', 'userId', userId);
                    localVarPath = "/groups/{groupId}/bans/{userId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates a Group and returns it.
         * @summary Update Group
         * @param {string} groupId Must be a valid group ID.
         * @param {UpdateGroupRequest} [updateGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: function (groupId, updateGroupRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('updateGroup', 'groupId', groupId);
                    localVarPath = "/groups/{groupId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateGroupRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates a gallery for a Group.
         * @summary Update Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupGallery: function (groupId, groupGalleryId, updateGroupGalleryRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('updateGroupGallery', 'groupId', groupId);
                    // verify required parameter 'groupGalleryId' is not null or undefined
                    (0, common_1.assertParamExists)('updateGroupGallery', 'groupGalleryId', groupGalleryId);
                    localVarPath = "/groups/{groupId}/galleries/{groupGalleryId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("groupGalleryId", "}"), encodeURIComponent(String(groupGalleryId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateGroupGalleryRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates a Group Member
         * @summary Update Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMember: function (groupId, userId, updateGroupMemberRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('updateGroupMember', 'groupId', groupId);
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('updateGroupMember', 'userId', userId);
                    localVarPath = "/groups/{groupId}/members/{userId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateGroupMemberRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates a group role by ID.
         * @summary Update Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRole: function (groupId, groupRoleId, updateGroupRoleRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'groupId' is not null or undefined
                    (0, common_1.assertParamExists)('updateGroupRole', 'groupId', groupId);
                    // verify required parameter 'groupRoleId' is not null or undefined
                    (0, common_1.assertParamExists)('updateGroupRole', 'groupRoleId', groupRoleId);
                    localVarPath = "/groups/{groupId}/roles/{groupRoleId}"
                        .replace("{".concat("groupId", "}"), encodeURIComponent(String(groupId)))
                        .replace("{".concat("groupRoleId", "}"), encodeURIComponent(String(groupRoleId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateGroupRoleRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.GroupsApiAxiosParamCreator = GroupsApiAxiosParamCreator;
/**
 * GroupsApi - functional programming interface
 * @export
 */
var GroupsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.GroupsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Adds an image to a Group gallery.
         * @summary Add Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {AddGroupGalleryImageRequest} [addGroupGalleryImageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupGalleryImage: function (groupId, groupGalleryId, addGroupGalleryImageRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.addGroupGalleryImage(groupId, groupGalleryId, addGroupGalleryImageRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Adds a Role to a Group Member
         * @summary Add Role to GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMemberRole: function (groupId, userId, groupRoleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.addGroupMemberRole(groupId, userId, groupRoleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Bans a user from a Group.
         * @summary Ban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {BanGroupMemberRequest} [banGroupMemberRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banGroupMember: function (groupId, banGroupMemberRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.banGroupMember(groupId, banGroupMemberRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Cancels a request sent to join the group.
         * @summary Cancel Group Join Request
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupRequest: function (groupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.cancelGroupRequest(groupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
         * @summary Create Group
         * @param {CreateGroupRequest} [createGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: function (createGroupRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createGroup(createGroupRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Creates an Announcement for a Group.
         * @summary Create Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupAnnouncementRequest} [createGroupAnnouncementRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupAnnouncement: function (groupId, createGroupAnnouncementRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createGroupAnnouncement(groupId, createGroupAnnouncementRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Creates a gallery for a Group.
         * @summary Create Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupGalleryRequest} [createGroupGalleryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupGallery: function (groupId, createGroupGalleryRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createGroupGallery(groupId, createGroupGalleryRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Sends an invite to a user to join the group.
         * @summary Invite User to Group
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupInviteRequest} [createGroupInviteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupInvite: function (groupId, createGroupInviteRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createGroupInvite(groupId, createGroupInviteRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Create a Group role.
         * @summary Create GroupRole
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupRoleRequest} [createGroupRoleRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupRole: function (groupId, createGroupRoleRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createGroupRole(groupId, createGroupRoleRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes a Group.
         * @summary Delete Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: function (groupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteGroup(groupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes the announcement for a Group.
         * @summary Delete Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupAnnouncement: function (groupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteGroupAnnouncement(groupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes a gallery for a Group.
         * @summary Delete Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupGallery: function (groupId, groupGalleryId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteGroupGallery(groupId, groupGalleryId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes an image from a Group gallery.
         * @summary Delete Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupGalleryImage: function (groupId, groupGalleryId, groupGalleryImageId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteGroupGalleryImage(groupId, groupGalleryId, groupGalleryImageId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes an Group invite sent to a User
         * @summary Delete User Invite
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupInvite: function (groupId, userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteGroupInvite(groupId, userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes a Group Role by ID and returns the remaining roles.
         * @summary Delete Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupRole: function (groupId, groupRoleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteGroupRole(groupId, groupRoleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a single Group by ID.
         * @summary Get Group by ID
         * @param {string} groupId Must be a valid group ID.
         * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: function (groupId, includeRoles, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroup(groupId, includeRoles, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
         * @summary Get Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAnnouncements: function (groupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroupAnnouncements(groupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of audit logs for a Group.
         * @summary Get Group Audit Logs
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [startDate] The start date of the search range.
         * @param {string} [endDate] The end date of the search range.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAuditLogs: function (groupId, n, offset, startDate, endDate, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroupAuditLogs(groupId, n, offset, startDate, endDate, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of banned users for a Group.
         * @summary Get Group Bans
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupBans: function (groupId, n, offset, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroupBans(groupId, n, offset, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of images for a Group gallery.
         * @summary Get Group Gallery Images
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupGalleryImages: function (groupId, groupGalleryId, n, offset, approved, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroupGalleryImages(groupId, groupGalleryId, n, offset, approved, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of members that have been invited to the Group.
         * @summary Get Group Invites Sent
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupInvites: function (groupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroupInvites(groupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a LimitedGroup Member.
         * @summary Get Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMember: function (groupId, userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroupMember(groupId, userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
         * @summary List Group Members
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {GroupSearchSort} [sort] The sort order of Group Member results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers: function (groupId, n, offset, sort, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroupMembers(groupId, n, offset, sort, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a List of all possible/available permissions for a Group.
         * @summary List Group Permissions
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissions: function (groupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroupPermissions(groupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of members that have requested to join the Group.
         * @summary Get Group Join Requests
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRequests: function (groupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroupRequests(groupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a Group Role by ID.
         * @summary Get Group Roles
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRoles: function (groupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGroupRoles(groupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Join a Group by ID and returns the member object.
         * @summary Join Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroup: function (groupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.joinGroup(groupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
         * @summary Kick Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickGroupMember: function (groupId, userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.kickGroupMember(groupId, userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Leave a group by ID.
         * @summary Leave Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroup: function (groupId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.leaveGroup(groupId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Removes a Role from a Group Member
         * @summary Remove Role from GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGroupMemberRole: function (groupId, userId, groupRoleId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.removeGroupMemberRole(groupId, userId, groupRoleId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Responds to a Group Join Request with Accept/Deny
         * @summary Respond Group Join request
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {RespondGroupJoinRequest} [respondGroupJoinRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondGroupJoinRequest: function (groupId, userId, respondGroupJoinRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.respondGroupJoinRequest(groupId, userId, respondGroupJoinRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Searches Groups by name or shortCode
         * @summary Search Group
         * @param {string} [query] Query to search for, can be either Group Name or Group shortCode
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroups: function (query, offset, n, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.searchGroups(query, offset, n, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Unbans a user from a Group.
         * @summary Unban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanGroupMember: function (groupId, userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unbanGroupMember(groupId, userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Updates a Group and returns it.
         * @summary Update Group
         * @param {string} groupId Must be a valid group ID.
         * @param {UpdateGroupRequest} [updateGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: function (groupId, updateGroupRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateGroup(groupId, updateGroupRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Updates a gallery for a Group.
         * @summary Update Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupGallery: function (groupId, groupGalleryId, updateGroupGalleryRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateGroupGallery(groupId, groupGalleryId, updateGroupGalleryRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Updates a Group Member
         * @summary Update Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMember: function (groupId, userId, updateGroupMemberRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateGroupMember(groupId, userId, updateGroupMemberRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Updates a group role by ID.
         * @summary Update Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRole: function (groupId, groupRoleId, updateGroupRoleRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateGroupRole(groupId, groupRoleId, updateGroupRoleRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.GroupsApiFp = GroupsApiFp;
/**
 * GroupsApi - factory interface
 * @export
 */
var GroupsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.GroupsApiFp)(configuration);
    return {
        /**
         * Adds an image to a Group gallery.
         * @summary Add Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {AddGroupGalleryImageRequest} [addGroupGalleryImageRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupGalleryImage: function (groupId, groupGalleryId, addGroupGalleryImageRequest, options) {
            return localVarFp.addGroupGalleryImage(groupId, groupGalleryId, addGroupGalleryImageRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Adds a Role to a Group Member
         * @summary Add Role to GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupMemberRole: function (groupId, userId, groupRoleId, options) {
            return localVarFp.addGroupMemberRole(groupId, userId, groupRoleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Bans a user from a Group.
         * @summary Ban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {BanGroupMemberRequest} [banGroupMemberRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banGroupMember: function (groupId, banGroupMemberRequest, options) {
            return localVarFp.banGroupMember(groupId, banGroupMemberRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Cancels a request sent to join the group.
         * @summary Cancel Group Join Request
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupRequest: function (groupId, options) {
            return localVarFp.cancelGroupRequest(groupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
         * @summary Create Group
         * @param {CreateGroupRequest} [createGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: function (createGroupRequest, options) {
            return localVarFp.createGroup(createGroupRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Creates an Announcement for a Group.
         * @summary Create Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupAnnouncementRequest} [createGroupAnnouncementRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupAnnouncement: function (groupId, createGroupAnnouncementRequest, options) {
            return localVarFp.createGroupAnnouncement(groupId, createGroupAnnouncementRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Creates a gallery for a Group.
         * @summary Create Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupGalleryRequest} [createGroupGalleryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupGallery: function (groupId, createGroupGalleryRequest, options) {
            return localVarFp.createGroupGallery(groupId, createGroupGalleryRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Sends an invite to a user to join the group.
         * @summary Invite User to Group
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupInviteRequest} [createGroupInviteRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupInvite: function (groupId, createGroupInviteRequest, options) {
            return localVarFp.createGroupInvite(groupId, createGroupInviteRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Create a Group role.
         * @summary Create GroupRole
         * @param {string} groupId Must be a valid group ID.
         * @param {CreateGroupRoleRequest} [createGroupRoleRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupRole: function (groupId, createGroupRoleRequest, options) {
            return localVarFp.createGroupRole(groupId, createGroupRoleRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes a Group.
         * @summary Delete Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: function (groupId, options) {
            return localVarFp.deleteGroup(groupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes the announcement for a Group.
         * @summary Delete Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupAnnouncement: function (groupId, options) {
            return localVarFp.deleteGroupAnnouncement(groupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes a gallery for a Group.
         * @summary Delete Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupGallery: function (groupId, groupGalleryId, options) {
            return localVarFp.deleteGroupGallery(groupId, groupGalleryId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes an image from a Group gallery.
         * @summary Delete Group Gallery Image
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupGalleryImage: function (groupId, groupGalleryId, groupGalleryImageId, options) {
            return localVarFp.deleteGroupGalleryImage(groupId, groupGalleryId, groupGalleryImageId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes an Group invite sent to a User
         * @summary Delete User Invite
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupInvite: function (groupId, userId, options) {
            return localVarFp.deleteGroupInvite(groupId, userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes a Group Role by ID and returns the remaining roles.
         * @summary Delete Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupRole: function (groupId, groupRoleId, options) {
            return localVarFp.deleteGroupRole(groupId, groupRoleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a single Group by ID.
         * @summary Get Group by ID
         * @param {string} groupId Must be a valid group ID.
         * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: function (groupId, includeRoles, options) {
            return localVarFp.getGroup(groupId, includeRoles, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
         * @summary Get Group Announcement
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAnnouncements: function (groupId, options) {
            return localVarFp.getGroupAnnouncements(groupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of audit logs for a Group.
         * @summary Get Group Audit Logs
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [startDate] The start date of the search range.
         * @param {string} [endDate] The end date of the search range.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAuditLogs: function (groupId, n, offset, startDate, endDate, options) {
            return localVarFp.getGroupAuditLogs(groupId, n, offset, startDate, endDate, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of banned users for a Group.
         * @summary Get Group Bans
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupBans: function (groupId, n, offset, options) {
            return localVarFp.getGroupBans(groupId, n, offset, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of images for a Group gallery.
         * @summary Get Group Gallery Images
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupGalleryImages: function (groupId, groupGalleryId, n, offset, approved, options) {
            return localVarFp.getGroupGalleryImages(groupId, groupGalleryId, n, offset, approved, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of members that have been invited to the Group.
         * @summary Get Group Invites Sent
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupInvites: function (groupId, options) {
            return localVarFp.getGroupInvites(groupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a LimitedGroup Member.
         * @summary Get Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMember: function (groupId, userId, options) {
            return localVarFp.getGroupMember(groupId, userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
         * @summary List Group Members
         * @param {string} groupId Must be a valid group ID.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {GroupSearchSort} [sort] The sort order of Group Member results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers: function (groupId, n, offset, sort, options) {
            return localVarFp.getGroupMembers(groupId, n, offset, sort, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a List of all possible/available permissions for a Group.
         * @summary List Group Permissions
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPermissions: function (groupId, options) {
            return localVarFp.getGroupPermissions(groupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of members that have requested to join the Group.
         * @summary Get Group Join Requests
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRequests: function (groupId, options) {
            return localVarFp.getGroupRequests(groupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a Group Role by ID.
         * @summary Get Group Roles
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRoles: function (groupId, options) {
            return localVarFp.getGroupRoles(groupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Join a Group by ID and returns the member object.
         * @summary Join Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroup: function (groupId, options) {
            return localVarFp.joinGroup(groupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
         * @summary Kick Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickGroupMember: function (groupId, userId, options) {
            return localVarFp.kickGroupMember(groupId, userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Leave a group by ID.
         * @summary Leave Group
         * @param {string} groupId Must be a valid group ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroup: function (groupId, options) {
            return localVarFp.leaveGroup(groupId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Removes a Role from a Group Member
         * @summary Remove Role from GroupMember
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGroupMemberRole: function (groupId, userId, groupRoleId, options) {
            return localVarFp.removeGroupMemberRole(groupId, userId, groupRoleId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Responds to a Group Join Request with Accept/Deny
         * @summary Respond Group Join request
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {RespondGroupJoinRequest} [respondGroupJoinRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondGroupJoinRequest: function (groupId, userId, respondGroupJoinRequest, options) {
            return localVarFp.respondGroupJoinRequest(groupId, userId, respondGroupJoinRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Searches Groups by name or shortCode
         * @summary Search Group
         * @param {string} [query] Query to search for, can be either Group Name or Group shortCode
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {number} [n] The number of objects to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroups: function (query, offset, n, options) {
            return localVarFp.searchGroups(query, offset, n, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Unbans a user from a Group.
         * @summary Unban Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanGroupMember: function (groupId, userId, options) {
            return localVarFp.unbanGroupMember(groupId, userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates a Group and returns it.
         * @summary Update Group
         * @param {string} groupId Must be a valid group ID.
         * @param {UpdateGroupRequest} [updateGroupRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: function (groupId, updateGroupRequest, options) {
            return localVarFp.updateGroup(groupId, updateGroupRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates a gallery for a Group.
         * @summary Update Group Gallery
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupGalleryId Must be a valid group gallery ID.
         * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupGallery: function (groupId, groupGalleryId, updateGroupGalleryRequest, options) {
            return localVarFp.updateGroupGallery(groupId, groupGalleryId, updateGroupGalleryRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates a Group Member
         * @summary Update Group Member
         * @param {string} groupId Must be a valid group ID.
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMember: function (groupId, userId, updateGroupMemberRequest, options) {
            return localVarFp.updateGroupMember(groupId, userId, updateGroupMemberRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates a group role by ID.
         * @summary Update Group Role
         * @param {string} groupId Must be a valid group ID.
         * @param {string} groupRoleId Must be a valid group role ID.
         * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRole: function (groupId, groupRoleId, updateGroupRoleRequest, options) {
            return localVarFp.updateGroupRole(groupId, groupRoleId, updateGroupRoleRequest, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.GroupsApiFactory = GroupsApiFactory;
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
var GroupsApi = /** @class */ (function (_super) {
    __extends(GroupsApi, _super);
    function GroupsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Adds an image to a Group gallery.
     * @summary Add Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {AddGroupGalleryImageRequest} [addGroupGalleryImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.addGroupGalleryImage = function (groupId, groupGalleryId, addGroupGalleryImageRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).addGroupGalleryImage(groupId, groupGalleryId, addGroupGalleryImageRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Adds a Role to a Group Member
     * @summary Add Role to GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.addGroupMemberRole = function (groupId, userId, groupRoleId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).addGroupMemberRole(groupId, userId, groupRoleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Bans a user from a Group.
     * @summary Ban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {BanGroupMemberRequest} [banGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.banGroupMember = function (groupId, banGroupMemberRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).banGroupMember(groupId, banGroupMemberRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Cancels a request sent to join the group.
     * @summary Cancel Group Join Request
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.cancelGroupRequest = function (groupId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).cancelGroupRequest(groupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
     * @summary Create Group
     * @param {CreateGroupRequest} [createGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.createGroup = function (createGroupRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).createGroup(createGroupRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Creates an Announcement for a Group.
     * @summary Create Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupAnnouncementRequest} [createGroupAnnouncementRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.createGroupAnnouncement = function (groupId, createGroupAnnouncementRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).createGroupAnnouncement(groupId, createGroupAnnouncementRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Creates a gallery for a Group.
     * @summary Create Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupGalleryRequest} [createGroupGalleryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.createGroupGallery = function (groupId, createGroupGalleryRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).createGroupGallery(groupId, createGroupGalleryRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Sends an invite to a user to join the group.
     * @summary Invite User to Group
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupInviteRequest} [createGroupInviteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.createGroupInvite = function (groupId, createGroupInviteRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).createGroupInvite(groupId, createGroupInviteRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Create a Group role.
     * @summary Create GroupRole
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupRoleRequest} [createGroupRoleRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.createGroupRole = function (groupId, createGroupRoleRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).createGroupRole(groupId, createGroupRoleRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes a Group.
     * @summary Delete Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.deleteGroup = function (groupId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).deleteGroup(groupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes the announcement for a Group.
     * @summary Delete Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.deleteGroupAnnouncement = function (groupId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).deleteGroupAnnouncement(groupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes a gallery for a Group.
     * @summary Delete Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.deleteGroupGallery = function (groupId, groupGalleryId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).deleteGroupGallery(groupId, groupGalleryId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes an image from a Group gallery.
     * @summary Delete Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.deleteGroupGalleryImage = function (groupId, groupGalleryId, groupGalleryImageId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).deleteGroupGalleryImage(groupId, groupGalleryId, groupGalleryImageId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes an Group invite sent to a User
     * @summary Delete User Invite
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.deleteGroupInvite = function (groupId, userId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).deleteGroupInvite(groupId, userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes a Group Role by ID and returns the remaining roles.
     * @summary Delete Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.deleteGroupRole = function (groupId, groupRoleId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).deleteGroupRole(groupId, groupRoleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a single Group by ID.
     * @summary Get Group by ID
     * @param {string} groupId Must be a valid group ID.
     * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroup = function (groupId, includeRoles, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroup(groupId, includeRoles, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
     * @summary Get Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroupAnnouncements = function (groupId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroupAnnouncements(groupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of audit logs for a Group.
     * @summary Get Group Audit Logs
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [startDate] The start date of the search range.
     * @param {string} [endDate] The end date of the search range.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroupAuditLogs = function (groupId, n, offset, startDate, endDate, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroupAuditLogs(groupId, n, offset, startDate, endDate, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of banned users for a Group.
     * @summary Get Group Bans
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroupBans = function (groupId, n, offset, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroupBans(groupId, n, offset, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of images for a Group gallery.
     * @summary Get Group Gallery Images
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroupGalleryImages = function (groupId, groupGalleryId, n, offset, approved, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroupGalleryImages(groupId, groupGalleryId, n, offset, approved, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of members that have been invited to the Group.
     * @summary Get Group Invites Sent
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroupInvites = function (groupId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroupInvites(groupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a LimitedGroup Member.
     * @summary Get Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroupMember = function (groupId, userId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroupMember(groupId, userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
     * @summary List Group Members
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {GroupSearchSort} [sort] The sort order of Group Member results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroupMembers = function (groupId, n, offset, sort, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroupMembers(groupId, n, offset, sort, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a List of all possible/available permissions for a Group.
     * @summary List Group Permissions
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroupPermissions = function (groupId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroupPermissions(groupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of members that have requested to join the Group.
     * @summary Get Group Join Requests
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroupRequests = function (groupId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroupRequests(groupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a Group Role by ID.
     * @summary Get Group Roles
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.getGroupRoles = function (groupId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).getGroupRoles(groupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Join a Group by ID and returns the member object.
     * @summary Join Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.joinGroup = function (groupId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).joinGroup(groupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
     * @summary Kick Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.kickGroupMember = function (groupId, userId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).kickGroupMember(groupId, userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Leave a group by ID.
     * @summary Leave Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.leaveGroup = function (groupId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).leaveGroup(groupId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Removes a Role from a Group Member
     * @summary Remove Role from GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.removeGroupMemberRole = function (groupId, userId, groupRoleId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).removeGroupMemberRole(groupId, userId, groupRoleId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Responds to a Group Join Request with Accept/Deny
     * @summary Respond Group Join request
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {RespondGroupJoinRequest} [respondGroupJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.respondGroupJoinRequest = function (groupId, userId, respondGroupJoinRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).respondGroupJoinRequest(groupId, userId, respondGroupJoinRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Searches Groups by name or shortCode
     * @summary Search Group
     * @param {string} [query] Query to search for, can be either Group Name or Group shortCode
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {number} [n] The number of objects to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.searchGroups = function (query, offset, n, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).searchGroups(query, offset, n, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Unbans a user from a Group.
     * @summary Unban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.unbanGroupMember = function (groupId, userId, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).unbanGroupMember(groupId, userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Updates a Group and returns it.
     * @summary Update Group
     * @param {string} groupId Must be a valid group ID.
     * @param {UpdateGroupRequest} [updateGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.updateGroup = function (groupId, updateGroupRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).updateGroup(groupId, updateGroupRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Updates a gallery for a Group.
     * @summary Update Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.updateGroupGallery = function (groupId, groupGalleryId, updateGroupGalleryRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).updateGroupGallery(groupId, groupGalleryId, updateGroupGalleryRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Updates a Group Member
     * @summary Update Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.updateGroupMember = function (groupId, userId, updateGroupMemberRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).updateGroupMember(groupId, userId, updateGroupMemberRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Updates a group role by ID.
     * @summary Update Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    GroupsApi.prototype.updateGroupRole = function (groupId, groupRoleId, updateGroupRoleRequest, options) {
        var _this = this;
        return (0, exports.GroupsApiFp)(this.configuration).updateGroupRole(groupId, groupRoleId, updateGroupRoleRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return GroupsApi;
}(base_1.BaseAPI));
exports.GroupsApi = GroupsApi;
/**
 * InstancesApi - axios parameter creator
 * @export
 */
var InstancesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
         * @summary Get Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance: function (worldId, instanceId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('getInstance', 'worldId', worldId);
                    // verify required parameter 'instanceId' is not null or undefined
                    (0, common_1.assertParamExists)('getInstance', 'instanceId', instanceId);
                    localVarPath = "/instances/{worldId}:{instanceId}"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)))
                        .replace("{".concat("instanceId", "}"), encodeURIComponent(String(instanceId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
         * @summary Get Instance By Short Name
         * @param {string} shortName Must be a valid instance short name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceByShortName: function (shortName, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'shortName' is not null or undefined
                    (0, common_1.assertParamExists)('getInstanceByShortName', 'shortName', shortName);
                    localVarPath = "/instances/s/{shortName}"
                        .replace("{".concat("shortName", "}"), encodeURIComponent(String(shortName)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns an instance short name.
         * @summary Get Instance Short Name
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortName: function (worldId, instanceId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('getShortName', 'worldId', worldId);
                    // verify required parameter 'instanceId' is not null or undefined
                    (0, common_1.assertParamExists)('getShortName', 'instanceId', instanceId);
                    localVarPath = "/instances/{worldId}:{instanceId}/shortName"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)))
                        .replace("{".concat("instanceId", "}"), encodeURIComponent(String(instanceId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Sends an invite to the instance to yourself.
         * @summary Send Self Invite
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSelfInvite: function (worldId, instanceId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('sendSelfInvite', 'worldId', worldId);
                    // verify required parameter 'instanceId' is not null or undefined
                    (0, common_1.assertParamExists)('sendSelfInvite', 'instanceId', instanceId);
                    localVarPath = "/instances/{worldId}:{instanceId}/invite"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)))
                        .replace("{".concat("instanceId", "}"), encodeURIComponent(String(instanceId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.InstancesApiAxiosParamCreator = InstancesApiAxiosParamCreator;
/**
 * InstancesApi - functional programming interface
 * @export
 */
var InstancesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.InstancesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
         * @summary Get Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance: function (worldId, instanceId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getInstance(worldId, instanceId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
         * @summary Get Instance By Short Name
         * @param {string} shortName Must be a valid instance short name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceByShortName: function (shortName, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getInstanceByShortName(shortName, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns an instance short name.
         * @summary Get Instance Short Name
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortName: function (worldId, instanceId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getShortName(worldId, instanceId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Sends an invite to the instance to yourself.
         * @summary Send Self Invite
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSelfInvite: function (worldId, instanceId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.sendSelfInvite(worldId, instanceId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.InstancesApiFp = InstancesApiFp;
/**
 * InstancesApi - factory interface
 * @export
 */
var InstancesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.InstancesApiFp)(configuration);
    return {
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
         * @summary Get Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance: function (worldId, instanceId, options) {
            return localVarFp.getInstance(worldId, instanceId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
         * @summary Get Instance By Short Name
         * @param {string} shortName Must be a valid instance short name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceByShortName: function (shortName, options) {
            return localVarFp.getInstanceByShortName(shortName, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns an instance short name.
         * @summary Get Instance Short Name
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShortName: function (worldId, instanceId, options) {
            return localVarFp.getShortName(worldId, instanceId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Sends an invite to the instance to yourself.
         * @summary Send Self Invite
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSelfInvite: function (worldId, instanceId, options) {
            return localVarFp.sendSelfInvite(worldId, instanceId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.InstancesApiFactory = InstancesApiFactory;
/**
 * InstancesApi - object-oriented interface
 * @export
 * @class InstancesApi
 * @extends {BaseAPI}
 */
var InstancesApi = /** @class */ (function (_super) {
    __extends(InstancesApi, _super);
    function InstancesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
     * @summary Get Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    InstancesApi.prototype.getInstance = function (worldId, instanceId, options) {
        var _this = this;
        return (0, exports.InstancesApiFp)(this.configuration).getInstance(worldId, instanceId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
     * @summary Get Instance By Short Name
     * @param {string} shortName Must be a valid instance short name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    InstancesApi.prototype.getInstanceByShortName = function (shortName, options) {
        var _this = this;
        return (0, exports.InstancesApiFp)(this.configuration).getInstanceByShortName(shortName, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns an instance short name.
     * @summary Get Instance Short Name
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    InstancesApi.prototype.getShortName = function (worldId, instanceId, options) {
        var _this = this;
        return (0, exports.InstancesApiFp)(this.configuration).getShortName(worldId, instanceId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Sends an invite to the instance to yourself.
     * @summary Send Self Invite
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    InstancesApi.prototype.sendSelfInvite = function (worldId, instanceId, options) {
        var _this = this;
        return (0, exports.InstancesApiFp)(this.configuration).sendSelfInvite(worldId, instanceId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return InstancesApi;
}(base_1.BaseAPI));
exports.InstancesApi = InstancesApi;
/**
 * InviteApi - axios parameter creator
 * @export
 */
var InviteApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Get Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteMessage: function (userId, messageType, slot, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('getInviteMessage', 'userId', userId);
                    // verify required parameter 'messageType' is not null or undefined
                    (0, common_1.assertParamExists)('getInviteMessage', 'messageType', messageType);
                    // verify required parameter 'slot' is not null or undefined
                    (0, common_1.assertParamExists)('getInviteMessage', 'slot', slot);
                    localVarPath = "/message/{userId}/{messageType}/{slot}"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)))
                        .replace("{".concat("messageType", "}"), encodeURIComponent(String(messageType)))
                        .replace("{".concat("slot", "}"), encodeURIComponent(String(slot)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary List Invite Messages
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteMessages: function (userId, messageType, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('getInviteMessages', 'userId', userId);
                    // verify required parameter 'messageType' is not null or undefined
                    (0, common_1.assertParamExists)('getInviteMessages', 'messageType', messageType);
                    localVarPath = "/message/{userId}/{messageType}"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)))
                        .replace("{".concat("messageType", "}"), encodeURIComponent(String(messageType)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Sends self an invite to an instance
         * @summary Invite Myself To Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMyselfTo: function (worldId, instanceId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('inviteMyselfTo', 'worldId', worldId);
                    // verify required parameter 'instanceId' is not null or undefined
                    (0, common_1.assertParamExists)('inviteMyselfTo', 'instanceId', instanceId);
                    localVarPath = "/invite/myself/to/{worldId}:{instanceId}"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)))
                        .replace("{".concat("instanceId", "}"), encodeURIComponent(String(instanceId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
         * @summary Invite User
         * @param {string} userId Must be a valid user ID.
         * @param {InviteRequest} [inviteRequest] Slot number of the Invite Message to use when inviting a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: function (userId, inviteRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('inviteUser', 'userId', userId);
                    localVarPath = "/invite/{userId}"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inviteRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
         * @summary Request Invite
         * @param {string} userId Must be a valid user ID.
         * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestInvite: function (userId, requestInviteRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('requestInvite', 'userId', userId);
                    localVarPath = "/requestInvite/{userId}"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(requestInviteRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
         * @summary Reset Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetInviteMessage: function (userId, messageType, slot, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('resetInviteMessage', 'userId', userId);
                    // verify required parameter 'messageType' is not null or undefined
                    (0, common_1.assertParamExists)('resetInviteMessage', 'messageType', messageType);
                    // verify required parameter 'slot' is not null or undefined
                    (0, common_1.assertParamExists)('resetInviteMessage', 'slot', slot);
                    localVarPath = "/message/{userId}/{messageType}/{slot}"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)))
                        .replace("{".concat("messageType", "}"), encodeURIComponent(String(messageType)))
                        .replace("{".concat("slot", "}"), encodeURIComponent(String(slot)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
         * @summary Respond Invite
         * @param {string} notificationId Must be a valid notification ID.
         * @param {InviteResponse} [inviteResponse] Slot number of the Response Message to use when responding to a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondInvite: function (notificationId, inviteResponse, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'notificationId' is not null or undefined
                    (0, common_1.assertParamExists)('respondInvite', 'notificationId', notificationId);
                    localVarPath = "/invite/{notificationId}/response"
                        .replace("{".concat("notificationId", "}"), encodeURIComponent(String(notificationId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inviteResponse, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Update Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteMessage: function (userId, messageType, slot, updateInviteMessageRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('updateInviteMessage', 'userId', userId);
                    // verify required parameter 'messageType' is not null or undefined
                    (0, common_1.assertParamExists)('updateInviteMessage', 'messageType', messageType);
                    // verify required parameter 'slot' is not null or undefined
                    (0, common_1.assertParamExists)('updateInviteMessage', 'slot', slot);
                    localVarPath = "/message/{userId}/{messageType}/{slot}"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)))
                        .replace("{".concat("messageType", "}"), encodeURIComponent(String(messageType)))
                        .replace("{".concat("slot", "}"), encodeURIComponent(String(slot)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateInviteMessageRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.InviteApiAxiosParamCreator = InviteApiAxiosParamCreator;
/**
 * InviteApi - functional programming interface
 * @export
 */
var InviteApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.InviteApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Get Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteMessage: function (userId, messageType, slot, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getInviteMessage(userId, messageType, slot, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary List Invite Messages
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteMessages: function (userId, messageType, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getInviteMessages(userId, messageType, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Sends self an invite to an instance
         * @summary Invite Myself To Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMyselfTo: function (worldId, instanceId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.inviteMyselfTo(worldId, instanceId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
         * @summary Invite User
         * @param {string} userId Must be a valid user ID.
         * @param {InviteRequest} [inviteRequest] Slot number of the Invite Message to use when inviting a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: function (userId, inviteRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.inviteUser(userId, inviteRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
         * @summary Request Invite
         * @param {string} userId Must be a valid user ID.
         * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestInvite: function (userId, requestInviteRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.requestInvite(userId, requestInviteRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
         * @summary Reset Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetInviteMessage: function (userId, messageType, slot, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.resetInviteMessage(userId, messageType, slot, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
         * @summary Respond Invite
         * @param {string} notificationId Must be a valid notification ID.
         * @param {InviteResponse} [inviteResponse] Slot number of the Response Message to use when responding to a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondInvite: function (notificationId, inviteResponse, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.respondInvite(notificationId, inviteResponse, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Update Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteMessage: function (userId, messageType, slot, updateInviteMessageRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateInviteMessage(userId, messageType, slot, updateInviteMessageRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.InviteApiFp = InviteApiFp;
/**
 * InviteApi - factory interface
 * @export
 */
var InviteApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.InviteApiFp)(configuration);
    return {
        /**
         * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Get Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteMessage: function (userId, messageType, slot, options) {
            return localVarFp.getInviteMessage(userId, messageType, slot, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary List Invite Messages
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInviteMessages: function (userId, messageType, options) {
            return localVarFp.getInviteMessages(userId, messageType, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Sends self an invite to an instance
         * @summary Invite Myself To Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteMyselfTo: function (worldId, instanceId, options) {
            return localVarFp.inviteMyselfTo(worldId, instanceId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
         * @summary Invite User
         * @param {string} userId Must be a valid user ID.
         * @param {InviteRequest} [inviteRequest] Slot number of the Invite Message to use when inviting a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: function (userId, inviteRequest, options) {
            return localVarFp.inviteUser(userId, inviteRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
         * @summary Request Invite
         * @param {string} userId Must be a valid user ID.
         * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestInvite: function (userId, requestInviteRequest, options) {
            return localVarFp.requestInvite(userId, requestInviteRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
         * @summary Reset Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetInviteMessage: function (userId, messageType, slot, options) {
            return localVarFp.resetInviteMessage(userId, messageType, slot, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
         * @summary Respond Invite
         * @param {string} notificationId Must be a valid notification ID.
         * @param {InviteResponse} [inviteResponse] Slot number of the Response Message to use when responding to a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondInvite: function (notificationId, inviteResponse, options) {
            return localVarFp.respondInvite(notificationId, inviteResponse, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
         * @summary Update Invite Message
         * @param {string} userId Must be a valid user ID.
         * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
         * @param {number} slot The message slot to fetch of a given message type.
         * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteMessage: function (userId, messageType, slot, updateInviteMessageRequest, options) {
            return localVarFp.updateInviteMessage(userId, messageType, slot, updateInviteMessageRequest, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.InviteApiFactory = InviteApiFactory;
/**
 * InviteApi - object-oriented interface
 * @export
 * @class InviteApi
 * @extends {BaseAPI}
 */
var InviteApi = /** @class */ (function (_super) {
    __extends(InviteApi, _super);
    function InviteApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Get Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    InviteApi.prototype.getInviteMessage = function (userId, messageType, slot, options) {
        var _this = this;
        return (0, exports.InviteApiFp)(this.configuration).getInviteMessage(userId, messageType, slot, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary List Invite Messages
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    InviteApi.prototype.getInviteMessages = function (userId, messageType, options) {
        var _this = this;
        return (0, exports.InviteApiFp)(this.configuration).getInviteMessages(userId, messageType, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Sends self an invite to an instance
     * @summary Invite Myself To Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    InviteApi.prototype.inviteMyselfTo = function (worldId, instanceId, options) {
        var _this = this;
        return (0, exports.InviteApiFp)(this.configuration).inviteMyselfTo(worldId, instanceId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
     * @summary Invite User
     * @param {string} userId Must be a valid user ID.
     * @param {InviteRequest} [inviteRequest] Slot number of the Invite Message to use when inviting a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    InviteApi.prototype.inviteUser = function (userId, inviteRequest, options) {
        var _this = this;
        return (0, exports.InviteApiFp)(this.configuration).inviteUser(userId, inviteRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
     * @summary Request Invite
     * @param {string} userId Must be a valid user ID.
     * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    InviteApi.prototype.requestInvite = function (userId, requestInviteRequest, options) {
        var _this = this;
        return (0, exports.InviteApiFp)(this.configuration).requestInvite(userId, requestInviteRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
     * @summary Reset Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    InviteApi.prototype.resetInviteMessage = function (userId, messageType, slot, options) {
        var _this = this;
        return (0, exports.InviteApiFp)(this.configuration).resetInviteMessage(userId, messageType, slot, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
     * @summary Respond Invite
     * @param {string} notificationId Must be a valid notification ID.
     * @param {InviteResponse} [inviteResponse] Slot number of the Response Message to use when responding to a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    InviteApi.prototype.respondInvite = function (notificationId, inviteResponse, options) {
        var _this = this;
        return (0, exports.InviteApiFp)(this.configuration).respondInvite(notificationId, inviteResponse, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Update Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    InviteApi.prototype.updateInviteMessage = function (userId, messageType, slot, updateInviteMessageRequest, options) {
        var _this = this;
        return (0, exports.InviteApiFp)(this.configuration).updateInviteMessage(userId, messageType, slot, updateInviteMessageRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return InviteApi;
}(base_1.BaseAPI));
exports.InviteApi = InviteApi;
/**
 * NotificationsApi - axios parameter creator
 * @export
 */
var NotificationsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
         * @summary Accept Friend Request
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest: function (notificationId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'notificationId' is not null or undefined
                    (0, common_1.assertParamExists)('acceptFriendRequest', 'notificationId', notificationId);
                    localVarPath = "/auth/user/notifications/{notificationId}/accept"
                        .replace("{".concat("notificationId", "}"), encodeURIComponent(String(notificationId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Clear **all** notifications.
         * @summary Clear All Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNotifications: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/user/notifications/clear";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Delete a notification.
         * @summary Delete Notification
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: function (notificationId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'notificationId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteNotification', 'notificationId', notificationId);
                    localVarPath = "/auth/user/notifications/{notificationId}/hide"
                        .replace("{".concat("notificationId", "}"), encodeURIComponent(String(notificationId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Retrieve all of the current user\'s notifications.
         * @summary List Notifications
         * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
         * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
         * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
         * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: function (type, sent, hidden, after, n, offset, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/user/notifications";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (type !== undefined) {
                        localVarQueryParameter['type'] = type;
                    }
                    if (sent !== undefined) {
                        localVarQueryParameter['sent'] = sent;
                    }
                    if (hidden !== undefined) {
                        localVarQueryParameter['hidden'] = hidden;
                    }
                    if (after !== undefined) {
                        localVarQueryParameter['after'] = after;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Mark a notification as seen.
         * @summary Mark Notification As Read
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markNotificationAsRead: function (notificationId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'notificationId' is not null or undefined
                    (0, common_1.assertParamExists)('markNotificationAsRead', 'notificationId', notificationId);
                    localVarPath = "/auth/user/notifications/{notificationId}/see"
                        .replace("{".concat("notificationId", "}"), encodeURIComponent(String(notificationId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.NotificationsApiAxiosParamCreator = NotificationsApiAxiosParamCreator;
/**
 * NotificationsApi - functional programming interface
 * @export
 */
var NotificationsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.NotificationsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
         * @summary Accept Friend Request
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest: function (notificationId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.acceptFriendRequest(notificationId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Clear **all** notifications.
         * @summary Clear All Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNotifications: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.clearNotifications(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Delete a notification.
         * @summary Delete Notification
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: function (notificationId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteNotification(notificationId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve all of the current user\'s notifications.
         * @summary List Notifications
         * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
         * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
         * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
         * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: function (type, sent, hidden, after, n, offset, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNotifications(type, sent, hidden, after, n, offset, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Mark a notification as seen.
         * @summary Mark Notification As Read
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markNotificationAsRead: function (notificationId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.markNotificationAsRead(notificationId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.NotificationsApiFp = NotificationsApiFp;
/**
 * NotificationsApi - factory interface
 * @export
 */
var NotificationsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.NotificationsApiFp)(configuration);
    return {
        /**
         * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
         * @summary Accept Friend Request
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest: function (notificationId, options) {
            return localVarFp.acceptFriendRequest(notificationId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Clear **all** notifications.
         * @summary Clear All Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNotifications: function (options) {
            return localVarFp.clearNotifications(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete a notification.
         * @summary Delete Notification
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: function (notificationId, options) {
            return localVarFp.deleteNotification(notificationId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve all of the current user\'s notifications.
         * @summary List Notifications
         * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
         * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
         * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
         * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: function (type, sent, hidden, after, n, offset, options) {
            return localVarFp.getNotifications(type, sent, hidden, after, n, offset, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Mark a notification as seen.
         * @summary Mark Notification As Read
         * @param {string} notificationId Must be a valid notification ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markNotificationAsRead: function (notificationId, options) {
            return localVarFp.markNotificationAsRead(notificationId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.NotificationsApiFactory = NotificationsApiFactory;
/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
var NotificationsApi = /** @class */ (function (_super) {
    __extends(NotificationsApi, _super);
    function NotificationsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
     * @summary Accept Friend Request
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    NotificationsApi.prototype.acceptFriendRequest = function (notificationId, options) {
        var _this = this;
        return (0, exports.NotificationsApiFp)(this.configuration).acceptFriendRequest(notificationId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Clear **all** notifications.
     * @summary Clear All Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    NotificationsApi.prototype.clearNotifications = function (options) {
        var _this = this;
        return (0, exports.NotificationsApiFp)(this.configuration).clearNotifications(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Delete a notification.
     * @summary Delete Notification
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    NotificationsApi.prototype.deleteNotification = function (notificationId, options) {
        var _this = this;
        return (0, exports.NotificationsApiFp)(this.configuration).deleteNotification(notificationId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve all of the current user\'s notifications.
     * @summary List Notifications
     * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
     * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
     * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
     * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    NotificationsApi.prototype.getNotifications = function (type, sent, hidden, after, n, offset, options) {
        var _this = this;
        return (0, exports.NotificationsApiFp)(this.configuration).getNotifications(type, sent, hidden, after, n, offset, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Mark a notification as seen.
     * @summary Mark Notification As Read
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    NotificationsApi.prototype.markNotificationAsRead = function (notificationId, options) {
        var _this = this;
        return (0, exports.NotificationsApiFp)(this.configuration).markNotificationAsRead(notificationId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return NotificationsApi;
}(base_1.BaseAPI));
exports.NotificationsApi = NotificationsApi;
/**
 * PermissionsApi - axios parameter creator
 * @export
 */
var PermissionsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
         * @summary Get Assigned Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedPermissions: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/permissions";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
         * @summary Get Permission
         * @param {string} permissionId Must be a valid permission ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission: function (permissionId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'permissionId' is not null or undefined
                    (0, common_1.assertParamExists)('getPermission', 'permissionId', permissionId);
                    localVarPath = "/permissions/{permissionId}"
                        .replace("{".concat("permissionId", "}"), encodeURIComponent(String(permissionId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.PermissionsApiAxiosParamCreator = PermissionsApiAxiosParamCreator;
/**
 * PermissionsApi - functional programming interface
 * @export
 */
var PermissionsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PermissionsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
         * @summary Get Assigned Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedPermissions: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAssignedPermissions(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
         * @summary Get Permission
         * @param {string} permissionId Must be a valid permission ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission: function (permissionId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPermission(permissionId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PermissionsApiFp = PermissionsApiFp;
/**
 * PermissionsApi - factory interface
 * @export
 */
var PermissionsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PermissionsApiFp)(configuration);
    return {
        /**
         * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
         * @summary Get Assigned Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedPermissions: function (options) {
            return localVarFp.getAssignedPermissions(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
         * @summary Get Permission
         * @param {string} permissionId Must be a valid permission ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission: function (permissionId, options) {
            return localVarFp.getPermission(permissionId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PermissionsApiFactory = PermissionsApiFactory;
/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
var PermissionsApi = /** @class */ (function (_super) {
    __extends(PermissionsApi, _super);
    function PermissionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
     * @summary Get Assigned Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    PermissionsApi.prototype.getAssignedPermissions = function (options) {
        var _this = this;
        return (0, exports.PermissionsApiFp)(this.configuration).getAssignedPermissions(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
     * @summary Get Permission
     * @param {string} permissionId Must be a valid permission ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    PermissionsApi.prototype.getPermission = function (permissionId, options) {
        var _this = this;
        return (0, exports.PermissionsApiFp)(this.configuration).getPermission(permissionId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PermissionsApi;
}(base_1.BaseAPI));
exports.PermissionsApi = PermissionsApi;
/**
 * PlayermoderationApi - axios parameter creator
 * @export
 */
var PlayermoderationApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * ⚠️ **This will delete every single player moderation you\'ve ever made.**
         * @summary Clear All Player Moderations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllPlayerModerations: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/user/playermoderations";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Deletes a specific player moderation based on it\'s `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
         * @summary Delete Player Moderation
         * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayerModeration: function (playerModerationId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'playerModerationId' is not null or undefined
                    (0, common_1.assertParamExists)('deletePlayerModeration', 'playerModerationId', playerModerationId);
                    localVarPath = "/auth/user/playermoderations/{playerModerationId}"
                        .replace("{".concat("playerModerationId", "}"), encodeURIComponent(String(playerModerationId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
         * @summary Get Player Moderation
         * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerModeration: function (playerModerationId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'playerModerationId' is not null or undefined
                    (0, common_1.assertParamExists)('getPlayerModeration', 'playerModerationId', playerModerationId);
                    localVarPath = "/auth/user/playermoderations/{playerModerationId}"
                        .replace("{".concat("playerModerationId", "}"), encodeURIComponent(String(playerModerationId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
         * @summary Search Player Moderations
         * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
         * @param {string} [targetUserId] Must be valid UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerModerations: function (type, targetUserId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/user/playermoderations";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (type !== undefined) {
                        localVarQueryParameter['type'] = type;
                    }
                    if (targetUserId !== undefined) {
                        localVarQueryParameter['targetUserId'] = targetUserId;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
         * @summary Moderate User
         * @param {ModerateUserRequest} [moderateUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderateUser: function (moderateUserRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/user/playermoderations";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(moderateUserRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
         * @summary Unmoderate User
         * @param {ModerateUserRequest} [moderateUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmoderateUser: function (moderateUserRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/auth/user/unplayermoderate";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(moderateUserRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.PlayermoderationApiAxiosParamCreator = PlayermoderationApiAxiosParamCreator;
/**
 * PlayermoderationApi - functional programming interface
 * @export
 */
var PlayermoderationApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PlayermoderationApiAxiosParamCreator)(configuration);
    return {
        /**
         * ⚠️ **This will delete every single player moderation you\'ve ever made.**
         * @summary Clear All Player Moderations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllPlayerModerations: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.clearAllPlayerModerations(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes a specific player moderation based on it\'s `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
         * @summary Delete Player Moderation
         * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayerModeration: function (playerModerationId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deletePlayerModeration(playerModerationId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
         * @summary Get Player Moderation
         * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerModeration: function (playerModerationId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPlayerModeration(playerModerationId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
         * @summary Search Player Moderations
         * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
         * @param {string} [targetUserId] Must be valid UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerModerations: function (type, targetUserId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPlayerModerations(type, targetUserId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
         * @summary Moderate User
         * @param {ModerateUserRequest} [moderateUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderateUser: function (moderateUserRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.moderateUser(moderateUserRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
         * @summary Unmoderate User
         * @param {ModerateUserRequest} [moderateUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmoderateUser: function (moderateUserRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unmoderateUser(moderateUserRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PlayermoderationApiFp = PlayermoderationApiFp;
/**
 * PlayermoderationApi - factory interface
 * @export
 */
var PlayermoderationApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PlayermoderationApiFp)(configuration);
    return {
        /**
         * ⚠️ **This will delete every single player moderation you\'ve ever made.**
         * @summary Clear All Player Moderations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllPlayerModerations: function (options) {
            return localVarFp.clearAllPlayerModerations(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes a specific player moderation based on it\'s `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
         * @summary Delete Player Moderation
         * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayerModeration: function (playerModerationId, options) {
            return localVarFp.deletePlayerModeration(playerModerationId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
         * @summary Get Player Moderation
         * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerModeration: function (playerModerationId, options) {
            return localVarFp.getPlayerModeration(playerModerationId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
         * @summary Search Player Moderations
         * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
         * @param {string} [targetUserId] Must be valid UserID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerModerations: function (type, targetUserId, options) {
            return localVarFp.getPlayerModerations(type, targetUserId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
         * @summary Moderate User
         * @param {ModerateUserRequest} [moderateUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderateUser: function (moderateUserRequest, options) {
            return localVarFp.moderateUser(moderateUserRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
         * @summary Unmoderate User
         * @param {ModerateUserRequest} [moderateUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmoderateUser: function (moderateUserRequest, options) {
            return localVarFp.unmoderateUser(moderateUserRequest, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PlayermoderationApiFactory = PlayermoderationApiFactory;
/**
 * PlayermoderationApi - object-oriented interface
 * @export
 * @class PlayermoderationApi
 * @extends {BaseAPI}
 */
var PlayermoderationApi = /** @class */ (function (_super) {
    __extends(PlayermoderationApi, _super);
    function PlayermoderationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * ⚠️ **This will delete every single player moderation you\'ve ever made.**
     * @summary Clear All Player Moderations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    PlayermoderationApi.prototype.clearAllPlayerModerations = function (options) {
        var _this = this;
        return (0, exports.PlayermoderationApiFp)(this.configuration).clearAllPlayerModerations(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes a specific player moderation based on it\'s `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
     * @summary Delete Player Moderation
     * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    PlayermoderationApi.prototype.deletePlayerModeration = function (playerModerationId, options) {
        var _this = this;
        return (0, exports.PlayermoderationApiFp)(this.configuration).deletePlayerModeration(playerModerationId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
     * @summary Get Player Moderation
     * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    PlayermoderationApi.prototype.getPlayerModeration = function (playerModerationId, options) {
        var _this = this;
        return (0, exports.PlayermoderationApiFp)(this.configuration).getPlayerModeration(playerModerationId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
     * @summary Search Player Moderations
     * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
     * @param {string} [targetUserId] Must be valid UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    PlayermoderationApi.prototype.getPlayerModerations = function (type, targetUserId, options) {
        var _this = this;
        return (0, exports.PlayermoderationApiFp)(this.configuration).getPlayerModerations(type, targetUserId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
     * @summary Moderate User
     * @param {ModerateUserRequest} [moderateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    PlayermoderationApi.prototype.moderateUser = function (moderateUserRequest, options) {
        var _this = this;
        return (0, exports.PlayermoderationApiFp)(this.configuration).moderateUser(moderateUserRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
     * @summary Unmoderate User
     * @param {ModerateUserRequest} [moderateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    PlayermoderationApi.prototype.unmoderateUser = function (moderateUserRequest, options) {
        var _this = this;
        return (0, exports.PlayermoderationApiFp)(this.configuration).unmoderateUser(moderateUserRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PlayermoderationApi;
}(base_1.BaseAPI));
exports.PlayermoderationApi = PlayermoderationApi;
/**
 * SystemApi - axios parameter creator
 * @export
 */
var SystemApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Fetches the CSS code to the frontend React website.
         * @summary Download CSS
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSS: function (variant, branch, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/css/app.css";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (variant !== undefined) {
                        localVarQueryParameter['variant'] = variant;
                    }
                    if (branch !== undefined) {
                        localVarQueryParameter['branch'] = branch;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
         * @summary Fetch API Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/config";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
         * @summary Current Online Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOnlineUsers: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/visits";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
         * @summary Check API Health
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getHealth: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/health";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
         * @summary Show Information Notices
         * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
         * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfoPush: function (require, include, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/infoPush";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (require !== undefined) {
                        localVarQueryParameter['require'] = require;
                    }
                    if (include !== undefined) {
                        localVarQueryParameter['include'] = include;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Fetches the JavaScript code to the frontend React website.
         * @summary Download JavaScript
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJavaScript: function (variant, branch, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/js/app.js";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (variant !== undefined) {
                        localVarQueryParameter['variant'] = variant;
                    }
                    if (branch !== undefined) {
                        localVarQueryParameter['branch'] = branch;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
         * @summary Current System Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemTime: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/time";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.SystemApiAxiosParamCreator = SystemApiAxiosParamCreator;
/**
 * SystemApi - functional programming interface
 * @export
 */
var SystemApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SystemApiAxiosParamCreator)(configuration);
    return {
        /**
         * Fetches the CSS code to the frontend React website.
         * @summary Download CSS
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSS: function (variant, branch, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCSS(variant, branch, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
         * @summary Fetch API Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConfig(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
         * @summary Current Online Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOnlineUsers: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCurrentOnlineUsers(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
         * @summary Check API Health
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getHealth: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getHealth(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
         * @summary Show Information Notices
         * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
         * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfoPush: function (require, include, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getInfoPush(require, include, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fetches the JavaScript code to the frontend React website.
         * @summary Download JavaScript
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJavaScript: function (variant, branch, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getJavaScript(variant, branch, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
         * @summary Current System Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemTime: function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSystemTime(options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SystemApiFp = SystemApiFp;
/**
 * SystemApi - factory interface
 * @export
 */
var SystemApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SystemApiFp)(configuration);
    return {
        /**
         * Fetches the CSS code to the frontend React website.
         * @summary Download CSS
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCSS: function (variant, branch, options) {
            return localVarFp.getCSS(variant, branch, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
         * @summary Fetch API Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: function (options) {
            return localVarFp.getConfig(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
         * @summary Current Online Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOnlineUsers: function (options) {
            return localVarFp.getCurrentOnlineUsers(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
         * @summary Check API Health
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getHealth: function (options) {
            return localVarFp.getHealth(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
         * @summary Show Information Notices
         * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
         * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfoPush: function (require, include, options) {
            return localVarFp.getInfoPush(require, include, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fetches the JavaScript code to the frontend React website.
         * @summary Download JavaScript
         * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
         * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJavaScript: function (variant, branch, options) {
            return localVarFp.getJavaScript(variant, branch, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
         * @summary Current System Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemTime: function (options) {
            return localVarFp.getSystemTime(options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SystemApiFactory = SystemApiFactory;
/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
var SystemApi = /** @class */ (function (_super) {
    __extends(SystemApi, _super);
    function SystemApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches the CSS code to the frontend React website.
     * @summary Download CSS
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    SystemApi.prototype.getCSS = function (variant, branch, options) {
        var _this = this;
        return (0, exports.SystemApiFp)(this.configuration).getCSS(variant, branch, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
     * @summary Fetch API Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    SystemApi.prototype.getConfig = function (options) {
        var _this = this;
        return (0, exports.SystemApiFp)(this.configuration).getConfig(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
     * @summary Current Online Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    SystemApi.prototype.getCurrentOnlineUsers = function (options) {
        var _this = this;
        return (0, exports.SystemApiFp)(this.configuration).getCurrentOnlineUsers(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
     * @summary Check API Health
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    SystemApi.prototype.getHealth = function (options) {
        var _this = this;
        return (0, exports.SystemApiFp)(this.configuration).getHealth(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
     * @summary Show Information Notices
     * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
     * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    SystemApi.prototype.getInfoPush = function (require, include, options) {
        var _this = this;
        return (0, exports.SystemApiFp)(this.configuration).getInfoPush(require, include, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fetches the JavaScript code to the frontend React website.
     * @summary Download JavaScript
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    SystemApi.prototype.getJavaScript = function (variant, branch, options) {
        var _this = this;
        return (0, exports.SystemApiFp)(this.configuration).getJavaScript(variant, branch, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
     * @summary Current System Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    SystemApi.prototype.getSystemTime = function (options) {
        var _this = this;
        return (0, exports.SystemApiFp)(this.configuration).getSystemTime(options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SystemApi;
}(base_1.BaseAPI));
exports.SystemApi = SystemApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
var UsersApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Get public user information about a specific user using their ID.
         * @summary Get User by ID
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('getUser', 'userId', userId);
                    localVarPath = "/users/{userId}"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
         * @summary Get User by Username
         * @param {string} username Username of the user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserByName: function (username, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'username' is not null or undefined
                    (0, common_1.assertParamExists)('getUserByName', 'username', username);
                    localVarPath = "/users/{username}/name"
                        .replace("{".concat("username", "}"), encodeURIComponent(String(username)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a list of Groups the user has requested to be invited into.
         * @summary Get User Group Requests
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupRequests: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('getUserGroupRequests', 'userId', userId);
                    localVarPath = "/users/{userId}/groups/requested"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get user\'s public groups
         * @summary Get User Groups
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: function (userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('getUserGroups', 'userId', userId);
                    localVarPath = "/users/{userId}/groups"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Search and list any users by text query
         * @summary Search All Users
         * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
         * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: function (search, developerType, n, offset, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/users";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (search !== undefined) {
                        localVarQueryParameter['search'] = search;
                    }
                    if (developerType !== undefined) {
                        localVarQueryParameter['developerType'] = developerType;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Update a users information such as the email and birthday.
         * @summary Update User Info
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateUserRequest} [updateUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: function (userId, updateUserRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'userId' is not null or undefined
                    (0, common_1.assertParamExists)('updateUser', 'userId', userId);
                    localVarPath = "/users/{userId}"
                        .replace("{".concat("userId", "}"), encodeURIComponent(String(userId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateUserRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;
/**
 * UsersApi - functional programming interface
 * @export
 */
var UsersApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.UsersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get public user information about a specific user using their ID.
         * @summary Get User by ID
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUser(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
         * @summary Get User by Username
         * @param {string} username Username of the user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserByName: function (username, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUserByName(username, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of Groups the user has requested to be invited into.
         * @summary Get User Group Requests
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupRequests: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUserGroupRequests(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get user\'s public groups
         * @summary Get User Groups
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: function (userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUserGroups(userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Search and list any users by text query
         * @summary Search All Users
         * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
         * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: function (search, developerType, n, offset, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.searchUsers(search, developerType, n, offset, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update a users information such as the email and birthday.
         * @summary Update User Info
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateUserRequest} [updateUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: function (userId, updateUserRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateUser(userId, updateUserRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.UsersApiFp = UsersApiFp;
/**
 * UsersApi - factory interface
 * @export
 */
var UsersApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.UsersApiFp)(configuration);
    return {
        /**
         * Get public user information about a specific user using their ID.
         * @summary Get User by ID
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: function (userId, options) {
            return localVarFp.getUser(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
         * @summary Get User by Username
         * @param {string} username Username of the user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserByName: function (username, options) {
            return localVarFp.getUserByName(username, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of Groups the user has requested to be invited into.
         * @summary Get User Group Requests
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupRequests: function (userId, options) {
            return localVarFp.getUserGroupRequests(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get user\'s public groups
         * @summary Get User Groups
         * @param {string} userId Must be a valid user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: function (userId, options) {
            return localVarFp.getUserGroups(userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Search and list any users by text query
         * @summary Search All Users
         * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
         * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
         * @param {number} [n] The number of objects to return.
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: function (search, developerType, n, offset, options) {
            return localVarFp.searchUsers(search, developerType, n, offset, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update a users information such as the email and birthday.
         * @summary Update User Info
         * @param {string} userId Must be a valid user ID.
         * @param {UpdateUserRequest} [updateUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: function (userId, updateUserRequest, options) {
            return localVarFp.updateUser(userId, updateUserRequest, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.UsersApiFactory = UsersApiFactory;
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
var UsersApi = /** @class */ (function (_super) {
    __extends(UsersApi, _super);
    function UsersApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get public user information about a specific user using their ID.
     * @summary Get User by ID
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    UsersApi.prototype.getUser = function (userId, options) {
        var _this = this;
        return (0, exports.UsersApiFp)(this.configuration).getUser(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
     * @summary Get User by Username
     * @param {string} username Username of the user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    UsersApi.prototype.getUserByName = function (username, options) {
        var _this = this;
        return (0, exports.UsersApiFp)(this.configuration).getUserByName(username, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of Groups the user has requested to be invited into.
     * @summary Get User Group Requests
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    UsersApi.prototype.getUserGroupRequests = function (userId, options) {
        var _this = this;
        return (0, exports.UsersApiFp)(this.configuration).getUserGroupRequests(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get user\'s public groups
     * @summary Get User Groups
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    UsersApi.prototype.getUserGroups = function (userId, options) {
        var _this = this;
        return (0, exports.UsersApiFp)(this.configuration).getUserGroups(userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Search and list any users by text query
     * @summary Search All Users
     * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
     * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    UsersApi.prototype.searchUsers = function (search, developerType, n, offset, options) {
        var _this = this;
        return (0, exports.UsersApiFp)(this.configuration).searchUsers(search, developerType, n, offset, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update a users information such as the email and birthday.
     * @summary Update User Info
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateUserRequest} [updateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    UsersApi.prototype.updateUser = function (userId, updateUserRequest, options) {
        var _this = this;
        return (0, exports.UsersApiFp)(this.configuration).updateUser(userId, updateUserRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return UsersApi;
}(base_1.BaseAPI));
exports.UsersApi = UsersApi;
/**
 * WorldsApi - axios parameter creator
 * @export
 */
var WorldsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
         * @summary Create World
         * @param {CreateWorldRequest} [createWorldRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorld: function (createWorldRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/worlds";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWorldRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
         * @summary Delete World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorld: function (worldId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('deleteWorld', 'worldId', worldId);
                    localVarPath = "/worlds/{worldId}"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Search and list currently Active worlds by query filters.
         * @summary List Active Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveWorlds: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/worlds/active";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (featured !== undefined) {
                        localVarQueryParameter['featured'] = featured;
                    }
                    if (sort !== undefined) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (search !== undefined) {
                        localVarQueryParameter['search'] = search;
                    }
                    if (tag !== undefined) {
                        localVarQueryParameter['tag'] = tag;
                    }
                    if (notag !== undefined) {
                        localVarQueryParameter['notag'] = notag;
                    }
                    if (releaseStatus !== undefined) {
                        localVarQueryParameter['releaseStatus'] = releaseStatus;
                    }
                    if (maxUnityVersion !== undefined) {
                        localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
                    }
                    if (minUnityVersion !== undefined) {
                        localVarQueryParameter['minUnityVersion'] = minUnityVersion;
                    }
                    if (platform !== undefined) {
                        localVarQueryParameter['platform'] = platform;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Search and list favorited worlds by query filters.
         * @summary List Favorited Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritedWorlds: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/worlds/favorites";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (featured !== undefined) {
                        localVarQueryParameter['featured'] = featured;
                    }
                    if (sort !== undefined) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (search !== undefined) {
                        localVarQueryParameter['search'] = search;
                    }
                    if (tag !== undefined) {
                        localVarQueryParameter['tag'] = tag;
                    }
                    if (notag !== undefined) {
                        localVarQueryParameter['notag'] = notag;
                    }
                    if (releaseStatus !== undefined) {
                        localVarQueryParameter['releaseStatus'] = releaseStatus;
                    }
                    if (maxUnityVersion !== undefined) {
                        localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
                    }
                    if (minUnityVersion !== undefined) {
                        localVarQueryParameter['minUnityVersion'] = minUnityVersion;
                    }
                    if (platform !== undefined) {
                        localVarQueryParameter['platform'] = platform;
                    }
                    if (userId !== undefined) {
                        localVarQueryParameter['userId'] = userId;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Search and list recently visited worlds by query filters.
         * @summary List Recent Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentWorlds: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/worlds/recent";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (featured !== undefined) {
                        localVarQueryParameter['featured'] = featured;
                    }
                    if (sort !== undefined) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (search !== undefined) {
                        localVarQueryParameter['search'] = search;
                    }
                    if (tag !== undefined) {
                        localVarQueryParameter['tag'] = tag;
                    }
                    if (notag !== undefined) {
                        localVarQueryParameter['notag'] = notag;
                    }
                    if (releaseStatus !== undefined) {
                        localVarQueryParameter['releaseStatus'] = releaseStatus;
                    }
                    if (maxUnityVersion !== undefined) {
                        localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
                    }
                    if (minUnityVersion !== undefined) {
                        localVarQueryParameter['minUnityVersion'] = minUnityVersion;
                    }
                    if (platform !== undefined) {
                        localVarQueryParameter['platform'] = platform;
                    }
                    if (userId !== undefined) {
                        localVarQueryParameter['userId'] = userId;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
         * @summary Get World by ID
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorld: function (worldId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('getWorld', 'worldId', worldId);
                    localVarPath = "/worlds/{worldId}"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a worlds instance.
         * @summary Get World Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorldInstance: function (worldId, instanceId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('getWorldInstance', 'worldId', worldId);
                    // verify required parameter 'instanceId' is not null or undefined
                    (0, common_1.assertParamExists)('getWorldInstance', 'instanceId', instanceId);
                    localVarPath = "/worlds/{worldId}/{instanceId}"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)))
                        .replace("{".concat("instanceId", "}"), encodeURIComponent(String(instanceId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
         * @summary Get World Metadata
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getWorldMetadata: function (worldId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('getWorldMetadata', 'worldId', worldId);
                    localVarPath = "/worlds/{worldId}/metadata"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a worlds publish status.
         * @summary Get World Publish Status
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorldPublishStatus: function (worldId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('getWorldPublishStatus', 'worldId', worldId);
                    localVarPath = "/worlds/{worldId}/publish"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Publish a world. You can only publish one world per week.
         * @summary Publish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishWorld: function (worldId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('publishWorld', 'worldId', worldId);
                    localVarPath = "/worlds/{worldId}/publish"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Search and list any worlds by query filters.
         * @summary Search All Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorlds: function (featured, sort, user, userId, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/worlds";
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    if (featured !== undefined) {
                        localVarQueryParameter['featured'] = featured;
                    }
                    if (sort !== undefined) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (user !== undefined) {
                        localVarQueryParameter['user'] = user;
                    }
                    if (userId !== undefined) {
                        localVarQueryParameter['userId'] = userId;
                    }
                    if (n !== undefined) {
                        localVarQueryParameter['n'] = n;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (offset !== undefined) {
                        localVarQueryParameter['offset'] = offset;
                    }
                    if (search !== undefined) {
                        localVarQueryParameter['search'] = search;
                    }
                    if (tag !== undefined) {
                        localVarQueryParameter['tag'] = tag;
                    }
                    if (notag !== undefined) {
                        localVarQueryParameter['notag'] = notag;
                    }
                    if (releaseStatus !== undefined) {
                        localVarQueryParameter['releaseStatus'] = releaseStatus;
                    }
                    if (maxUnityVersion !== undefined) {
                        localVarQueryParameter['maxUnityVersion'] = maxUnityVersion;
                    }
                    if (minUnityVersion !== undefined) {
                        localVarQueryParameter['minUnityVersion'] = minUnityVersion;
                    }
                    if (platform !== undefined) {
                        localVarQueryParameter['platform'] = platform;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Unpublish a world.
         * @summary Unpublish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishWorld: function (worldId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('unpublishWorld', 'worldId', worldId);
                    localVarPath = "/worlds/{worldId}/publish"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Update information about a specific World.
         * @summary Update World
         * @param {string} worldId Must be a valid world ID.
         * @param {UpdateWorldRequest} [updateWorldRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorld: function (worldId, updateWorldRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'worldId' is not null or undefined
                    (0, common_1.assertParamExists)('updateWorld', 'worldId', worldId);
                    localVarPath = "/worlds/{worldId}"
                        .replace("{".concat("worldId", "}"), encodeURIComponent(String(worldId)));
                    localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    // authentication authCookie required
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWorldRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.WorldsApiAxiosParamCreator = WorldsApiAxiosParamCreator;
/**
 * WorldsApi - functional programming interface
 * @export
 */
var WorldsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.WorldsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
         * @summary Create World
         * @param {CreateWorldRequest} [createWorldRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorld: function (createWorldRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createWorld(createWorldRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
         * @summary Delete World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorld: function (worldId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteWorld(worldId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Search and list currently Active worlds by query filters.
         * @summary List Active Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveWorlds: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getActiveWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Search and list favorited worlds by query filters.
         * @summary List Favorited Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritedWorlds: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFavoritedWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Search and list recently visited worlds by query filters.
         * @summary List Recent Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentWorlds: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getRecentWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
         * @summary Get World by ID
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorld: function (worldId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorld(worldId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a worlds instance.
         * @summary Get World Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorldInstance: function (worldId, instanceId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorldInstance(worldId, instanceId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
         * @summary Get World Metadata
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getWorldMetadata: function (worldId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorldMetadata(worldId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a worlds publish status.
         * @summary Get World Publish Status
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorldPublishStatus: function (worldId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorldPublishStatus(worldId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Publish a world. You can only publish one world per week.
         * @summary Publish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishWorld: function (worldId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.publishWorld(worldId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Search and list any worlds by query filters.
         * @summary Search All Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorlds: function (featured, sort, user, userId, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.searchWorlds(featured, sort, user, userId, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Unpublish a world.
         * @summary Unpublish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishWorld: function (worldId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unpublishWorld(worldId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update information about a specific World.
         * @summary Update World
         * @param {string} worldId Must be a valid world ID.
         * @param {UpdateWorldRequest} [updateWorldRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorld: function (worldId, updateWorldRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateWorld(worldId, updateWorldRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.WorldsApiFp = WorldsApiFp;
/**
 * WorldsApi - factory interface
 * @export
 */
var WorldsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.WorldsApiFp)(configuration);
    return {
        /**
         * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
         * @summary Create World
         * @param {CreateWorldRequest} [createWorldRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorld: function (createWorldRequest, options) {
            return localVarFp.createWorld(createWorldRequest, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
         * @summary Delete World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorld: function (worldId, options) {
            return localVarFp.deleteWorld(worldId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Search and list currently Active worlds by query filters.
         * @summary List Active Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveWorlds: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
            return localVarFp.getActiveWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Search and list favorited worlds by query filters.
         * @summary List Favorited Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoritedWorlds: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
            return localVarFp.getFavoritedWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Search and list recently visited worlds by query filters.
         * @summary List Recent Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {string} [userId] Target user to see information on, admin-only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentWorlds: function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
            return localVarFp.getRecentWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
         * @summary Get World by ID
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorld: function (worldId, options) {
            return localVarFp.getWorld(worldId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a worlds instance.
         * @summary Get World Instance
         * @param {string} worldId Must be a valid world ID.
         * @param {string} instanceId Must be a valid instance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorldInstance: function (worldId, instanceId, options) {
            return localVarFp.getWorldInstance(worldId, instanceId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
         * @summary Get World Metadata
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getWorldMetadata: function (worldId, options) {
            return localVarFp.getWorldMetadata(worldId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a worlds publish status.
         * @summary Get World Publish Status
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorldPublishStatus: function (worldId, options) {
            return localVarFp.getWorldPublishStatus(worldId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Publish a world. You can only publish one world per week.
         * @summary Publish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishWorld: function (worldId, options) {
            return localVarFp.publishWorld(worldId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Search and list any worlds by query filters.
         * @summary Search All Worlds
         * @param {boolean} [featured] Filters on featured results.
         * @param {SortOption} [sort] The sort order of the results.
         * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
         * @param {string} [userId] Filter by UserID.
         * @param {number} [n] The number of objects to return.
         * @param {OrderOption} [order] Result ordering
         * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
         * @param {string} [search] Filters by world name.
         * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
         * @param {string} [notag] Tags to exclude (comma-separated).
         * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
         * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
         * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
         * @param {string} [platform] The platform the asset supports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorlds: function (featured, sort, user, userId, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
            return localVarFp.searchWorlds(featured, sort, user, userId, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Unpublish a world.
         * @summary Unpublish World
         * @param {string} worldId Must be a valid world ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishWorld: function (worldId, options) {
            return localVarFp.unpublishWorld(worldId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update information about a specific World.
         * @summary Update World
         * @param {string} worldId Must be a valid world ID.
         * @param {UpdateWorldRequest} [updateWorldRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorld: function (worldId, updateWorldRequest, options) {
            return localVarFp.updateWorld(worldId, updateWorldRequest, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.WorldsApiFactory = WorldsApiFactory;
/**
 * WorldsApi - object-oriented interface
 * @export
 * @class WorldsApi
 * @extends {BaseAPI}
 */
var WorldsApi = /** @class */ (function (_super) {
    __extends(WorldsApi, _super);
    function WorldsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
     * @summary Create World
     * @param {CreateWorldRequest} [createWorldRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.createWorld = function (createWorldRequest, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).createWorld(createWorldRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
     * @summary Delete World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.deleteWorld = function (worldId, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).deleteWorld(worldId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Search and list currently Active worlds by query filters.
     * @summary List Active Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.getActiveWorlds = function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).getActiveWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Search and list favorited worlds by query filters.
     * @summary List Favorited Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.getFavoritedWorlds = function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).getFavoritedWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Search and list recently visited worlds by query filters.
     * @summary List Recent Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.getRecentWorlds = function (featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).getRecentWorlds(featured, sort, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, userId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
     * @summary Get World by ID
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.getWorld = function (worldId, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).getWorld(worldId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a worlds instance.
     * @summary Get World Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.getWorldInstance = function (worldId, instanceId, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).getWorldInstance(worldId, instanceId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
     * @summary Get World Metadata
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.getWorldMetadata = function (worldId, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).getWorldMetadata(worldId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a worlds publish status.
     * @summary Get World Publish Status
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.getWorldPublishStatus = function (worldId, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).getWorldPublishStatus(worldId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Publish a world. You can only publish one world per week.
     * @summary Publish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.publishWorld = function (worldId, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).publishWorld(worldId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Search and list any worlds by query filters.
     * @summary Search All Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.searchWorlds = function (featured, sort, user, userId, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).searchWorlds(featured, sort, user, userId, n, order, offset, search, tag, notag, releaseStatus, maxUnityVersion, minUnityVersion, platform, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Unpublish a world.
     * @summary Unpublish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.unpublishWorld = function (worldId, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).unpublishWorld(worldId, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update information about a specific World.
     * @summary Update World
     * @param {string} worldId Must be a valid world ID.
     * @param {UpdateWorldRequest} [updateWorldRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    WorldsApi.prototype.updateWorld = function (worldId, updateWorldRequest, options) {
        var _this = this;
        return (0, exports.WorldsApiFp)(this.configuration).updateWorld(worldId, updateWorldRequest, options).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return WorldsApi;
}(base_1.BaseAPI));
exports.WorldsApi = WorldsApi;
